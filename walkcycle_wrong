#ifndef WALK_CYCLE_H
#define WALK_CYCLE_H

#include <math.h>
#include "robot_spec.h"     // For LEG_COUNT, baseFootPositionWalk, bodyVelocity, walkParams, etc.
#include "math_utils.h"     // For Vec3, clampf, etc.
// #include "body_transform.h" // Not directly used here, but transformWalkFrameToLegFrame is used by the caller
// #include "ik.h"             // Not directly used here, but calculateIK is used by the caller

// --- Per-Leg Walk Cycle State ---
struct LegCycleData {
    Vec3 currentPosition;      // Current target foot position in Walk Frame {X,Y,Z} (cm)
    Vec3 swingLiftOffPosition; // Position in Walk Frame at the start of its swing phase
                               // For legs in stance, this can be updated to reflect current pos if needed
                               // but primarily used by swinging legs.
};

// --- Walk Cycle Parameters Struct Definition ---
// Define it here if it's self-contained within walkcycle logic
struct WalkParams {
  float stepHeight = 3.0f;
  float stepFrequency = 1.0f;
  float dutyFactor = 0.5f;
};

// --- Define Global Walk Control Variables directly in this header ---
WalkParams walkParams; // Default initialized by the struct definition
bool walkCycleRunning = true;

// Internal state for this module
LegCycleData legCycleData[LEG_COUNT]; // Holds the state for each leg

enum RobotGaitState {
    S_IDLE,
    S_TRIPOD1_SWING,      // Tripod 1 (0,2,4) swings, Tripod 2 (1,3,5) is in stance
    S_ALL_STANCE_POST_T1, // Optional pause state after T1 plants
    S_TRIPOD2_SWING,      // Tripod 2 (1,3,5) swings, Tripod 1 (0,2,4) is in stance
    S_ALL_STANCE_POST_T2  // Optional pause state after T2 plants
};

static RobotGaitState currentGaitState = S_IDLE;
static float currentProgressInState = 0.0f; // Normalized progress (0.0 to 1.0) within the current state
static float targetDurationForCurrentState = 0.0f; // Duration in seconds for the current state

// Define tripod leg groups (adjust if your leg numbering or desired grouping is different)
const uint8_t TRIPOD_1_LEGS[] = {0, 2, 4}; // Example: BackRight, FrontRight, MidLeft
const uint8_t TRIPOD_2_LEGS[] = {1, 3, 5}; // Example: MidRight, BackLeft, FrontLeft
const int NUM_LEGS_PER_TRIPOD = 3;


// --- Helper Function Declarations (Implementations below or adapt from old walkcycle.h) ---
static float helper_bell_curve_lift(float t_norm);
static float helper_quintic_interpolate_pos(float p0, float p1, float v0, float v1, float T, float t);
static Vec3 calculate_target_touchdown_pos_for_leg(uint8_t leg_index, const Vec3& body_vel_at_calc_time, float ang_vel_at_calc_time, float T_stance_duration_for_aiming);
static void perform_stance_phase_for_leg(uint8_t leg_index, float dt, const Vec3& current_body_velocity, float current_body_angular_velocity_yaw);
static void perform_swing_phase_for_leg(uint8_t leg_index, float normalized_swing_progress, const Vec3& target_touchdown_pos, const Vec3& current_body_velocity);


// --- Function Implementations ---

/**
 * @brief Initializes the walk cycle state machine and leg data.
 */
void setupWalkcycle() {
    currentGaitState = S_IDLE;
    currentProgressInState = 0.0f;
    targetDurationForCurrentState = 0.0f; // Will be set when transitioning out of IDLE

    for (int i = 0; i < LEG_COUNT; ++i) {
        legCycleData[i].currentPosition = baseFootPositionWalk[i];
        legCycleData[i].swingLiftOffPosition = baseFootPositionWalk[i]; // Initialize lift-off to base
    }
    // walkCycleRunning is controlled externally
    Serial.println("State-Driven Walk Cycle Initialized.");
}


/**
 * @brief Main update function for the state-driven hexapod walk cycle.
 * @param dt Time elapsed since the last update (in seconds).
 */
void updateWalkCycle(float dt) {
    if (!walkCycleRunning && currentGaitState != S_IDLE) {
        // If walking is disabled externally, transition to IDLE immediately
        currentGaitState = S_IDLE;
        currentProgressInState = 0.0f;
        // Snap legs to base positions upon stopping
        for (int i = 0; i < LEG_COUNT; ++i) {
            legCycleData[i].currentPosition = baseFootPositionWalk[i];
        }
    }

    if (currentGaitState == S_IDLE && !walkCycleRunning) {
        // If truly idle and commanded to be stopped, do nothing further.
        // Legs are already at baseFootPositionWalk from setup or previous transition.
        return;
    }

    // --- Calculate Durations based on GUI parameters ---
    // Ensure walkParams.stepFrequency is not zero to avoid division by zero
    float T_robot_cycle = (walkParams.stepFrequency > 1e-6f) ? 1.0f / walkParams.stepFrequency : 1e6f;
    float df_gui = clampf(walkParams.dutyFactor, 0.5f, 0.99f); // Clamp duty factor for this model
                                                              // 0.5 = no pause, >0.5 = pause
    float T_half_robot_cycle = T_robot_cycle / 2.0f;
    float T_actual_swing_motion_duration;
    float T_pause_duration;

    if (df_gui <= 0.501f) { // Using 0.501 to handle floating point comparisons
        T_actual_swing_motion_duration = T_half_robot_cycle;
        T_pause_duration = 0.0f;
    } else {
        // pause_ratio: 0 for df_gui=0.5, 1 for df_gui=1.0 (though we clamp df_gui)
        float pause_ratio = (df_gui - 0.5f) / 0.5f;
        T_pause_duration = T_half_robot_cycle * pause_ratio;
        T_actual_swing_motion_duration = T_half_robot_cycle * (1.0f - pause_ratio);
    }
    // Ensure durations are not negative if logic or inputs are strange
    T_actual_swing_motion_duration = fmaxf(0.0f, T_actual_swing_motion_duration);
    T_pause_duration = fmaxf(0.0f, T_pause_duration);


    // --- State Machine Logic ---
    RobotGaitState previous_state_for_entry_logic = currentGaitState; // For detecting state entry

    // Update progress in current state
    if (targetDurationForCurrentState > 1e-6f) {
        currentProgressInState += dt / targetDurationForCurrentState;
    } else {
        currentProgressInState = 1.0f; // Auto-complete if duration is zero
    }

    // --- Transition Logic (if current state completed) ---
    if (currentProgressInState >= 1.0f) {
        currentProgressInState = 0.0f; // Reset for the new state

        bool is_commanded_to_move = (bodyVelocity.normSq() > 1e-4f || fabsf(bodyAngularVelocityYaw) > 1e-3f);

        if (!is_commanded_to_move) {
            currentGaitState = S_IDLE; // If no movement command, always go to IDLE
        } else {
            // Determine next state based on current state when movement is commanded
            switch (currentGaitState) {
                case S_IDLE: // Was idle, now moving
                case S_ALL_STANCE_POST_T2:
                    currentGaitState = S_TRIPOD1_SWING;
                    break;
                case S_TRIPOD1_SWING:
                    currentGaitState = (T_pause_duration > 1e-6f) ? S_ALL_STANCE_POST_T1 : S_TRIPOD2_SWING;
                    break;
                case S_ALL_STANCE_POST_T1:
                    currentGaitState = S_TRIPOD2_SWING;
                    break;
                case S_TRIPOD2_SWING:
                    currentGaitState = (T_pause_duration > 1e-6f) ? S_ALL_STANCE_POST_T2 : S_TRIPOD1_SWING;
                    break;
                // default case not strictly needed if all states covered
            }
        }
    }

    // --- Actions ON ENTRY to a new state (if state changed) ---
    bool just_entered_new_state = (currentGaitState != previous_state_for_entry_logic || (currentProgressInState < (dt/targetDurationForCurrentState + 1e-5f) && currentProgressInState !=0.0f) );
    // The check for currentProgressInState is a bit of a hack to catch the first tick in a new state if dt makes progress slightly non-zero.
    // A cleaner way is a dedicated 'justEnteredState' flag set during transition. Let's refine this.

    static bool stateEntryFlag = true; // True when a state is newly entered
    if(currentGaitState != previous_state_for_entry_logic) {
        stateEntryFlag = true;
        currentProgressInState = 0.0f; // Ensure progress is exactly 0 on new state entry
    }


    if (stateEntryFlag) {
        Serial.print("Entering State: "); Serial.println(currentGaitState); // Debug
        switch (currentGaitState) {
            case S_IDLE:
                targetDurationForCurrentState = 1.0f; // Arbitrary, idle doesn't "progress"
                for (int i = 0; i < LEG_COUNT; ++i) { // Snap to base positions
                    legCycleData[i].currentPosition = baseFootPositionWalk[i];
                }
                break;
            case S_TRIPOD1_SWING:
                targetDurationForCurrentState = T_actual_swing_motion_duration;
                for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                    uint8_t leg_idx = TRIPOD_1_LEGS[i];
                    legCycleData[leg_idx].swingLiftOffPosition = legCycleData[leg_idx].currentPosition;
                }
                break;
            case S_ALL_STANCE_POST_T1:
                targetDurationForCurrentState = T_pause_duration;
                break;
            case S_TRIPOD2_SWING:
                targetDurationForCurrentState = T_actual_swing_motion_duration;
                for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                    uint8_t leg_idx = TRIPOD_2_LEGS[i];
                    legCycleData[leg_idx].swingLiftOffPosition = legCycleData[leg_idx].currentPosition;
                }
                break;
            case S_ALL_STANCE_POST_T2:
                targetDurationForCurrentState = T_pause_duration;
                break;
        }
    }


    // --- Actions WITHIN Current State ---
    // Stance duration for aiming swing foot (half of the *other* tripod's swing time, effectively)
    // This is used to calculate how far the body moves while a foot is aiming for touchdown.
    // A simpler T_stance_for_aiming could be T_actual_swing_motion_duration.
    float T_stance_for_aiming = T_actual_swing_motion_duration;


    switch (currentGaitState) {
        case S_IDLE:
            // Legs are already at baseFootPositionWalk.
            // If walkCycleRunning becomes true AND movement is commanded, transition happens above.
            if (walkCycleRunning && (bodyVelocity.normSq() > 1e-4f || fabsf(bodyAngularVelocityYaw) > 1e-3f)) {
                 // This explicit transition from IDLE if commanded to move
                 currentGaitState = S_TRIPOD1_SWING;
                 stateEntryFlag = true; // Force re-entry logic for S_TRIPOD1_SWING
                 currentProgressInState = 0.0f; // Reset progress
                 // Re-run entry logic for S_TRIPOD1_SWING immediately
                 // This is a bit of a state machine "jump", ensure it's clean.
                 // The stateEntryFlag mechanism should handle this.
            }
            break;

        case S_TRIPOD1_SWING: {
            // Tripod 1 (Swinging)
            for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                uint8_t leg_idx = TRIPOD_1_LEGS[i];
                Vec3 target_td_pos = calculate_target_touchdown_pos_for_leg(leg_idx, bodyVelocity, bodyAngularVelocityYaw, T_stance_for_aiming);
                perform_swing_phase_for_leg(leg_idx, currentProgressInState, target_td_pos, bodyVelocity);
            }
            // Tripod 2 (Stance)
            for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                uint8_t leg_idx = TRIPOD_2_LEGS[i];
                perform_stance_phase_for_leg(leg_idx, dt, bodyVelocity, bodyAngularVelocityYaw);
            }
            break;
        }
        case S_ALL_STANCE_POST_T1: {
            // All legs in stance
            for (int i = 0; i < LEG_COUNT; ++i) {
                perform_stance_phase_for_leg(i, dt, bodyVelocity, bodyAngularVelocityYaw);
            }
            break;
        }
        case S_TRIPOD2_SWING: {
            // Tripod 2 (Swinging)
            for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                uint8_t leg_idx = TRIPOD_2_LEGS[i];
                Vec3 target_td_pos = calculate_target_touchdown_pos_for_leg(leg_idx, bodyVelocity, bodyAngularVelocityYaw, T_stance_for_aiming);
                perform_swing_phase_for_leg(leg_idx, currentProgressInState, target_td_pos, bodyVelocity);
            }
            // Tripod 1 (Stance)
            for (int i = 0; i < NUM_LEGS_PER_TRIPOD; ++i) {
                uint8_t leg_idx = TRIPOD_1_LEGS[i];
                perform_stance_phase_for_leg(leg_idx, dt, bodyVelocity, bodyAngularVelocityYaw);
            }
            break;
        }
        case S_ALL_STANCE_POST_T2: {
            // All legs in stance
            for (int i = 0; i < LEG_COUNT; ++i) {
                perform_stance_phase_for_leg(i, dt, bodyVelocity, bodyAngularVelocityYaw);
            }
            break;
        }
    }
    stateEntryFlag = false; // Reset flag after processing state actions
}


// --- Helper Function Implementations ---

/**
 * @brief Generates a smooth vertical lift profile (0 to 1).
 * t_norm: Normalized time (0.0 to 1.0)
 */
static float helper_bell_curve_lift(float t_norm) {
    t_norm = clampf(t_norm, 0.0f, 1.0f);
    float t_minus_1 = 1.0f - t_norm;
    return 64.0f * (t_norm * t_norm * t_norm) * (t_minus_1 * t_minus_1 * t_minus_1); // Peaks at 1.0 for t_norm=0.5
}

/**
 * @brief Quintic Hermite interpolation for position.
 */
static float helper_quintic_interpolate_pos(float p0, float p1, float v0, float v1, float T_duration, float t_current) {
    if (T_duration <= 1e-9f) return p0;
    t_current = clampf(t_current, 0.0f, T_duration);
    float tn = t_current / T_duration; // Normalized time (0 to 1)
    // ... (quintic coefficients as in your old walkcycle.h or standard formulation)
    float tn2 = tn*tn; float tn3 = tn2*tn; float tn4 = tn3*tn; float tn5 = tn4*tn;
    float h00 =  1.0f - 10.0f*tn3 + 15.0f*tn4 -  6.0f*tn5;
    float h10 =  tn   -  6.0f*tn3 +  8.0f*tn4 -  3.0f*tn5; // Scaled by T_duration in use
    float h01 =         10.0f*tn3 - 15.0f*tn4 +  6.0f*tn5;
    float h11 =        -  4.0f*tn3 +  7.0f*tn4 -  3.0f*tn5; // Scaled by T_duration in use
    return h00*p0 + h10*T_duration*v0 + h01*p1 + h11*T_duration*v1;
}

/**
 * @brief Calculates the target touchdown position for a leg in the Walk Frame.
 * This is where the leg aims to land at the end of its swing.
 * T_stance_duration_for_aiming: How long the *other* tripod will be in stance (and thus how far the body moves)
 *                               while this leg is completing its swing and the subsequent stance.
 *                               Typically, this is T_actual_swing_motion_duration of the *other* tripod.
 */
static Vec3 calculate_target_touchdown_pos_for_leg(uint8_t leg_index,
                                             const Vec3& body_vel_at_calc_time,
                                             float ang_vel_at_calc_time,
                                             float T_stance_duration_for_aiming) {
    // Target is the base position, moved forward by half the body's travel during a stance phase.
    Vec3 targetPos = baseFootPositionWalk[leg_index];

    // Linear displacement compensation
    targetPos += body_vel_at_calc_time * (T_stance_duration_for_aiming * 0.5f);

    // Rotational displacement compensation (around Z axis of Walk Frame)
    // Angle of rotation during half a stance phase
    float rotation_angle = ang_vel_at_calc_time * (T_stance_duration_for_aiming * 0.5f);
    float cos_ra = cosf(rotation_angle);
    float sin_ra = sinf(rotation_angle);

    float original_x = targetPos.x;
    float original_y = targetPos.y;
    targetPos.x = original_x * cos_ra - original_y * sin_ra;
    targetPos.y = original_x * sin_ra + original_y * cos_ra;
    // Z is not affected by this rotation for touchdown target calculation.

    return targetPos;
}

/**
 * @brief Updates a leg's position during its stance phase.
 * Moves the foot "backward" relative to the Walk Frame to counteract body motion.
 */
static void perform_stance_phase_for_leg(uint8_t leg_index, float dt,
                                   const Vec3& current_body_velocity,
                                   float current_body_angular_velocity_yaw) {
    LegCycleData& leg = legCycleData[leg_index];

    // Linear motion: foot moves opposite to body velocity
    leg.currentPosition -= current_body_velocity * dt;

    // Rotational motion: foot rotates opposite to body yaw
    float delta_angle = -current_body_angular_velocity_yaw * dt; // Counter-rotation
    float cos_da = cosf(delta_angle);
    float sin_da = sinf(delta_angle);
    float original_x = leg.currentPosition.x;
    float original_y = leg.currentPosition.y;
    leg.currentPosition.x = original_x * cos_da - original_y * sin_da;
    leg.currentPosition.y = original_x * sin_da + original_y * cos_da;
    // leg.currentPosition.z remains unchanged during stance horizontal movement.
}

/**
 * @brief Updates a leg's position during its swing phase.
 * Interpolates from swingLiftOffPosition to target_touchdown_pos.
 * normalized_swing_progress: 0.0 (lift-off) to 1.0 (touchdown).
 */
static void perform_swing_phase_for_leg(uint8_t leg_index, float normalized_swing_progress,
                                  const Vec3& target_touchdown_pos,
                                  const Vec3& current_body_velocity) {
    LegCycleData& leg = legCycleData[leg_index];
    normalized_swing_progress = clampf(normalized_swing_progress, 0.0f, 1.0f);

    // Vertical motion (Z): Bell curve for lift
    // Interpolate Z from lift-off Z to target Z, then add bell curve lift
    float z_lift_off = leg.swingLiftOffPosition.z;
    float z_target_touchdown = target_touchdown_pos.z; // Usually baseFootPositionWalk[leg_index].z
    float z_along_chord = mapf(normalized_swing_progress, 0.0f, 1.0f, z_lift_off, z_target_touchdown);
    leg.currentPosition.z = z_along_chord + walkParams.stepHeight * helper_bell_curve_lift(normalized_swing_progress);

    // Horizontal motion (X, Y): Quintic interpolation
    // For quintic, we need start/end velocities. Assume zero velocity *relative to ground*
    // at lift-off and touchdown for smooth transitions.
    // So, v0 and v1 for interpolation are -current_body_velocity.
    // T_duration for quintic is targetDurationForCurrentState (the swing motion duration)
    // t_current for quintic is normalized_swing_progress * targetDurationForCurrentState

    float T_swing_motion_dur = targetDurationForCurrentState; // Should be T_actual_swing_motion_duration
    float t_curr_in_swing = normalized_swing_progress * T_swing_motion_dur;

    leg.currentPosition.x = helper_quintic_interpolate_pos(
        leg.swingLiftOffPosition.x, target_touchdown_pos.x,
        -current_body_velocity.x, -current_body_velocity.x, // v0_x, v1_x (relative to ground)
        T_swing_motion_dur, t_curr_in_swing
    );
    leg.currentPosition.y = helper_quintic_interpolate_pos(
        leg.swingLiftOffPosition.y, target_touchdown_pos.y,
        -current_body_velocity.y, -current_body_velocity.y, // v0_y, v1_y (relative to ground)
        T_swing_motion_dur, t_curr_in_swing
    );
}

#endif // WALK_CYCLE_H