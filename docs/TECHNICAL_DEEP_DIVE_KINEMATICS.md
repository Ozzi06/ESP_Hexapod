# Technical Deep Dive: Kinematics & Walk Cycle

This document details the coordinate frames, transformation pipeline, inverse kinematics (IK), and walk cycle logic used by the hexapod to achieve motion. Understanding these concepts is crucial for modifying the robot's movement behavior or adapting it to different physical dimensions.

## 1. Coordinate Frames Used

The robot's software utilizes several coordinate frames to define and transform positions and orientations:

*   **World/Ground Frame (Implicit):**
    *   A fixed, absolute reference frame, typically imagined on the floor where the robot operates. While not explicitly used in calculations with an origin, its Z-axis aligns with gravity.

*   **Walk Frame:**
    *   **Origin:** Directly on the ground, vertically aligned below the geometric center of the robot's body when the body is at its neutral/default height.
    *   **Axes:**
        *   `+Z`: Points upwards, opposite to gravity.
        *   `+Y`: Points in the robot's intended forward direction of travel.
        *   `+X`: Points to the robot's right, following the right-hand rule.
    *   **Characteristics:** This frame is gravity-aligned and *does not* tilt or rotate with the robot's body. It serves as a stable plane for defining desired foot step locations relative to the ground beneath the robot. Foot positions generated by the walk cycle are initially in this frame.

*   **Body Frame:**
    *   **Origin:** At the geometric center of the robot's main body chassis.
    *   **Axes:**
        *   `+Z`: Points "up" relative to the robot's body.
        *   `+Y`: Points "forward" relative to the robot's body.
        *   `+X`: Points "right" relative to the robot's body.
    *   **Characteristics:** This frame translates and rotates along with the robot's body. The positions of each leg's coxa (hip) joint (`legOriginOffset`) are defined relative to this Body Frame origin and expressed in Body Frame coordinates. The robot's overall desired pose (`bodyPositionOffset` and `bodyOrientation`) is defined as the transformation from the Walk Frame to this Body Frame.

*   **Leg IK Frame (per leg):**
    *   **Origin:** At the center of rotation of the specific leg's coxa (hip) joint.
    *   **Axes Orientation:** This frame is essentially the Body Frame translated to the leg's coxa joint and then rotated around the Body Frame's Z-axis by that leg's `legMountingAngle`.
        *   `+Z`: Points "up" along the coxa joint's physical rotation axis (aligned with the Body Frame's Z-axis).
        *   `+Y`: Points in the direction the leg extends horizontally when its coxa angle is 90 degrees (this is considered the leg's local "forward" direction for IK calculations).
        *   `+X`: Points to the "right" relative to the leg's local forward direction.
    *   **Characteristics:** The inverse kinematics function (`calculateIK`) expects the target foot-tip coordinates `{x, y, z}` to be provided in this local Leg IK Frame. This specific orientation ensures that `atan2(y, x)` correctly computes the coxa angle based on the desired displacement relative to the leg's specific mounting.

*(A simple diagram illustrating these frames, especially Walk, Body, and one Leg IK Frame, would be beneficial here. This can be added later as an image.)*

## 2. Transformation Pipeline: From Walk Frame Target to Servo Angles

The process of taking a desired foot position in the Walk Frame and converting it into individual servo commands involves several steps, primarily orchestrated by `updateWalkCycle()` in `walkcycle.cpp` and utility functions:

**Input:** `P_foot_walk` - Desired foot-tip position `{x,y,z}` in the Walk Frame (from `walkcycle.cpp`).

**Step A: Transform Walk Frame target to Leg IK Frame input (`transformWalkFrameToLegFrame` in `body_transform.h`)**

This function takes `P_foot_walk` and the `leg_index` and calculates `P_foot_leg_ik_input`, the coordinates required by the `calculateIK` function.

1.  **Get Current Body Pose:**
    *   `bodyPositionOffset`: A `Vec3` representing the translation of the Body Frame's origin from the Walk Frame's origin (expressed in Walk Frame coordinates).
    *   `bodyOrientation`: A `Quaternion` representing the rotation of the Body Frame relative to the Walk Frame axes.

2.  **Calculate Foot Position Relative to Body Origin (expressed in Body Frame axes):**
    *   `V_body_to_foot_walk = P_foot_walk - bodyPositionOffset`: This vector points from the Body Frame's current origin to the desired foot position, still expressed using Walk Frame axes.
    *   `Q_body_walk_inv = bodyOrientation.conjugate()`: Calculates the inverse rotation to transform from Walk Frame axes to Body Frame axes.
    *   `P_foot_body = rotate_vector_by_quaternion(V_body_to_foot_walk, Q_body_walk_inv)`: The foot's target position is now relative to the Body Frame's origin and expressed in Body Frame axes.

3.  **Calculate Foot Position Relative to Leg's Coxa Origin (still in Body Frame axes):**
    *   `legOriginOffset[leg_index]`: A `Vec3` (from `robot_spec.h`) defining the position of the current leg's coxa joint relative to the Body Frame origin, in Body Frame coordinates.
    *   `V_leg_to_foot_body = P_foot_body - legOriginOffset[leg_index]`: This vector points from the leg's coxa joint to the foot target, with its components still aligned with the Body Frame's axes.

4.  **Rotate into the Leg's Local IK Frame Axes:**
    *   `legMountingAngle[leg_index]`: A `float` (from `robot_spec.h`) defining the yaw rotation of the leg's mounting relative to the Body Frame's forward direction.
    *   `Q_mount_inv = Quaternion::from_axis_angle({0.0f, 0.0f, 1.0f}, -legMountingAngle[leg_index])`: Creates a quaternion for the inverse rotation (rotation by the negative mounting angle around the Z-axis). This transforms coordinates from the Body Frame's orientation into the Leg IK Frame's specific orientation.
    *   `P_foot_leg_ik_input = rotate_vector_by_quaternion(V_leg_to_foot_body, Q_mount_inv)`: This is the final `Vec3 {x,y,z}` output of this function. It represents the target foot-tip position relative to the leg's coxa joint, expressed in the Leg IK Frame's local axes, ready for `calculateIK`.

**Output of Step A:** `P_foot_leg_ik_input` - Target foot position for `calculateIK`.

**Step B: Calculate Joint Angles using Inverse Kinematics (`calculateIK` in `ik.h`)**

This function takes the `P_foot_leg_ik_input` (as `x, y, z`) and the leg segment lengths (`COXA_LENGTH`, `FEMUR_LENGTH`, `TIBIA_LENGTH` from `robot_spec.h`).

1.  **Coxa Angle (Yaw - rotation around Z-axis of Leg IK Frame):**
    *   `coxaAngle = atan2(y, x)`: Calculates the angle in the XY-plane of the Leg IK Frame. Given the frame's definition, a `coxaAngle` of +90 degrees (PI/2 radians) would typically align the rest of the leg along the Leg IK Frame's +Y axis (the leg's "forward" extension).
    *   The function checks if `coxaAngle` is within `COXA_MIN_ANGLE` and `COXA_MAX_ANGLE` (adjusted by `servo_center_angle[0]`).

2.  **Calculate Distances for Femur/Tibia Plane:**
    *   `h_hor = sqrt(x*x + y*y) - COXA_LENGTH`: This calculates `l_eff`, the effective horizontal distance from the Femur joint's axis of rotation to the target foot-tip, projected onto the leg's XY plane (after accounting for the coxa link's length).
    *   `h = sqrt(h_hor*h_hor + z*z)`: This is `d1`, the direct 3D distance from the Femur joint's axis to the foot-tip. This `h` and the `FEMUR_LENGTH` and `TIBIA_LENGTH` form a 2D triangle in the vertical plane containing the femur and tibia. The `z` here is the vertical displacement of the foot-tip relative to the coxa joint.

3.  **Femur Angle (Pitch):**
    *   `A = acos((FEMUR_LENGTH^2 + h^2 - TIBIA_LENGTH^2) / (2 * FEMUR_LENGTH * h))`: Angle `alpha1` from the Law of Cosines within the femur-tibia-h triangle. This is the angle at the femur joint between the femur link and the line `h`.
    *   `ah = asin(z/h)`: Angle `alpha2` which is the angle of the line `h` with respect to the leg's horizontal plane (defined by `h_hor`).
    *   `femurAngle = A + ah`: The sum gives the total angle of the femur relative to the leg's horizontal plane.
    *   The angle is then normalized to the range [-PI, PI].
    *   The function checks if `femurAngle` is within `FEMUR_MIN_ANGLE` and `FEMUR_MAX_ANGLE` (adjusted by `servo_center_angle[1]`).

4.  **Tibia Angle (Pitch):**
    *   `C = -acos((FEMUR_LENGTH^2 + TIBIA_LENGTH^2 - h^2) / (2 * FEMUR_LENGTH * TIBIA_LENGTH))`: Angle `beta` from the Law of Cosines. This is the angle at the tibia joint (knee) between the extended line of the femur and the tibia link. The negative sign is conventionally used depending on how the angle is defined (e.g., 0 degrees for a straight leg, negative for bent).
    *   `tibiaAngle = M_PI - C`: Adjusts the angle convention. If `C` is the interior angle of the "knee", then `M_PI - C` would be the angle if 0 degrees tibia means collinear with femur pointing outwards.
    *   The angle is then normalized to the range [-PI, PI].
    *   The function checks if `tibiaAngle` is within `TIBIA_MIN_ANGLE` and `TIBIA_MAX_ANGLE` (adjusted by `servo_center_angle[2]`).

**Output of Step B:** `coxaAngle`, `femurAngle`, `tibiaAngle` (logical joint angles in radians).

**Step C: Convert Logical Angles to Servo Pulses (`setAngleRadians` calling `get_pulse_from_angle_radians` in `servo_angles.h`)**

This function takes the logical angle from IK, the target `servo_channel`, and uses calibration data.

1.  **Apply Servo Center Offset:**
    *   `servo_center_angle[joint_type]` (from `robot_spec.h`): This offset defines the *logical joint angle* that corresponds to the servo motor's own electrical center/midpoint (the position it goes to with a `SERVOMIDDLE` pulse, typically 1500Âµs).
    *   For example, if `servo_center_angle[tibia]` is `-PI/4` radians (-45 degrees), it means that when the tibia joint is logically at -45 degrees, its servo is at its electrical midpoint.
    *   The value passed to the mapping function is `angle_for_mapping = logical_IK_angle - servo_center_angle[joint_type]`. This calculates how far the servo needs to move *from its electrical midpoint* to achieve the desired `logical_IK_angle`.
        *   E.g., If IK wants `logical_tibia_angle = 0` and `servo_center_angle[tibia] = -PI/4`, then `angle_for_mapping = 0 - (-PI/4) = +PI/4`. The servo needs to move +PI/4 radians from its electrical center.

2.  **Map to Pulse Width:**
    *   The `angle_for_mapping` (which is now relative to the servo's electrical center) is then clamped to the servo's operational range (e.g., +/- 76 degrees from center, defined by `SERVOMIN`/`SERVOMAX` mapping) using `clampmapf`.
    *   This mapped value is the PWM pulse width (e.g., between 175 and 535 for the typical values in `servo_angles.h`).

3.  **Command Servo:**
    *   The calculated pulse is sent to the appropriate PCA9685 servo driver channel.
    *   The `latestServoAngles[]` array is updated with the `logical_IK_angle` for telemetry/debugging.

**Output of Step C:** PWM pulse sent to the servo.

## 3. Walk Cycle (`walkcycle.cpp`)

The walk cycle generates the `P_foot_walk` targets for each leg.

*   **Gait Type:** The current implementation uses a **tripod gait**.
    *   Legs {0 (BR), 2 (FR), 4 (ML)} form one tripod.
    *   Legs {1 (MR), 3 (BL), 5 (FL)} form the other tripod.
    *   One tripod is in its "swing" phase (lifting and moving forward) while the other is in its "stance" phase (on the ground, moving the body forward).
*   **State Machine (`walkState`):**
    *   `IdleStance`: All feet on the ground, attempting to hold their `baseFootPositionWalk` if no body motion is commanded. If motion is commanded, transitions to a swing state.
    *   `TripodSwing1`: Tripod 1 swings, Tripod 2 is in stance.
    *   `TripodSwing2`: Tripod 2 swings, Tripod 1 is in stance.
*   **Parameters (`walkParams`):**
    *   `stepHeight`: The maximum height (in cm, Walk Frame Z-axis) a foot lifts off the ground during its swing phase.
    *   `stepTime`: The total duration (in seconds) for one complete step cycle (stance + swing) for a leg. The swing phase duration is `stepTime * dutyFactor` and stance is `stepTime * (1-dutyFactor)`. *Correction: The current code seems to imply `stepTime` is just for the swing phase, and stance duration is implicitly managed by the gait progress across both tripods.* The code uses `gaitProgress` from 0 to 1 over `walkParams.stepTime` for the *swinging tripod*.
*   **Swing Phase Trajectory:**
    *   **Horizontal (XY):** The foot moves from its `swingStartPosition` (where it lifted off) to a calculated `targetTouchdownPos`. This target is based on the leg's `baseFootPositionWalk` (neutral stance point) adjusted by the body's predicted movement (`bodyVelocity` and `bodyAngularVelocityYaw`) during half a step time, ensuring the foot lands ahead to support future motion. A quintic Hermite spline (`quintic_interpolate_pos`) is used for smooth XY motion from start to target over the `walkParams.stepTime`.
    *   **Vertical (Z):** The foot lifts up to `walkParams.stepHeight` at the midpoint of the swing and returns to the target Z height. A bell curve profile (`bell_curve_lift`) generates this smooth vertical motion.
*   **Stance Phase:**
    *   The foot remains planted on the ground. Its position in the Walk Frame is updated by subtracting the body's linear velocity (`bodyVelocity * dt`) and applying a counter-rotation based on `bodyAngularVelocityYaw * dt`. This makes the foot appear stationary relative to the ground while the body moves over it.
    *   The `swingStartPosition` for the *next* swing is continuously updated to where the foot currently is during stance.
*   **Integration with Body Motion:**
    *   `bodyVelocity` (Vec3, cm/s in Walk Frame) and `bodyAngularVelocityYaw` (float, rad/s around Walk Frame Z) are global variables set by `remote_control.cpp` based on user input.
    *   These velocities influence both the stance phase (to keep feet planted) and the swing phase (to aim the touchdown point correctly for continuous motion).

## 4. Key Files for Kinematics & Motion

*   **`robot_spec.h/.cpp`**: Defines all physical dimensions, mounting angles, and default positions crucial for kinematics.
*   **`math_utils.h/.cpp`**: Provides `Vec3` and `Quaternion` math.
*   **`body_transform.h`**: Handles transformations between Walk, Body, and Leg IK frames.
*   **`ik.h`**: Contains the core 3-DOF leg inverse kinematics solver.
*   **`walkcycle.h/.cpp`**: Implements the gait logic and generates target foot positions.
*   **`servo_angles.h/.cpp`**: Converts logical joint angles to PWM pulses, applying calibration.

---