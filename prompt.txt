import socket
import struct
import time
import math # For converting radians to degrees for display, if desired

# --- Configuration (MUST MATCH ESP32 SETUP) ---
LISTEN_IP = "0.0.0.0"      # Listen on all available network interfaces
LISTEN_PORT = 5006         # Must match angleBroadcastPort in ESP32 code
# Define MAX_SERVOS based on your robot_spec.h (e.g., LEG_COUNT * 3)
MAX_SERVOS = 18            # <--- CHANGE THIS to your robot's total servo count
# --- End Configuration ---

# --- Calculated values ---
EXPECTED_ANGLES = MAX_SERVOS
BYTES_PER_FLOAT = 4        # Standard size for C float
EXPECTED_PACKET_SIZE = EXPECTED_ANGLES * BYTES_PER_FLOAT
# '<' means little-endian (common for ESP32), 'f' means float. Repeat 'f' for each angle.
STRUCT_FORMAT = '<' + 'f' * EXPECTED_ANGLES
PRINT_INTERVAL_S = 0.1 # How often to print received data (seconds)
DISPLAY_IN_DEGREES = True # Set to False to display in radians
# ---

print(f"Starting UDP Angle Listener on {LISTEN_IP}:{LISTEN_PORT}")
print(f"Expecting {EXPECTED_ANGLES} angles ({EXPECTED_PACKET_SIZE} bytes) per packet.")
print(f"Struct format: '{STRUCT_FORMAT}'")
print(f"Displaying angles in: {'Degrees' if DISPLAY_IN_DEGREES else 'Radians'}")

# Create UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Allow address reuse (optional, can help avoid "address already in use" errors)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Bind the socket to the listen address and port
try:
    sock.bind((LISTEN_IP, LISTEN_PORT))
    # Set a timeout so the loop doesn't block forever if no data comes
    sock.settimeout(0.5) # seconds
except OSError as e:
    print(f"\nError binding socket: {e}")
    print(f"Is another program using port {LISTEN_PORT}? Exiting.")
    exit(1)

print("Socket bound successfully. Waiting for angle data...")

last_print_time = time.monotonic()
packet_count = 0
angles = [0.0] * EXPECTED_ANGLES # Initialize with zeros

try:
    while True:
        try:
            # Receive data
            data, addr = sock.recvfrom(1024) # Buffer size, 1024 should be plenty

            # --- Validation ---
            if len(data) == EXPECTED_PACKET_SIZE:
                packet_count += 1
                # --- Unpack the received bytes into floats ---
                # The result 'unpacked_angles' will be a tuple
                unpacked_angles = struct.unpack(STRUCT_FORMAT, data)

                # --- Optional: Convert to list or use tuple directly ---
                angles = list(unpacked_angles) # More convenient if modifying later

                # --- Periodic Printing ---
                current_time = time.monotonic()
                if current_time - last_print_time >= PRINT_INTERVAL_S:
                    # Format angles for printing
                    if DISPLAY_IN_DEGREES:
                        # Convert radians to degrees for display
                        display_angles = [math.degrees(a) for a in angles]
                        unit = "deg"
                        format_spec = "+6.1f" # Format: +123.4
                    else:
                        display_angles = angles
                        unit = "rad"
                        format_spec = "+5.3f" # Format: +1.234

                    # Create the string representation
                    angle_str = ", ".join([f"{a:{format_spec}}" for a in display_angles])
                    print(f"\rRecv {packet_count:<6}: [{angle_str}] ({unit}) from {addr[0]} ", end="")
                    last_print_time = current_time

            elif len(data) > 0: # Avoid printing warnings for zero-byte packets if they occur
                print(f"\n[Warning] Received packet of unexpected size {len(data)} from {addr[0]}. Expected {EXPECTED_PACKET_SIZE}. Ignoring.")
                # Optionally print first few bytes if debugging:
                # print(f"          Data (hex): {data[:16].hex()}...")


        except socket.timeout:
            # No data received within the timeout, just continue looping
            # Display a waiting message if nothing received for a while
            if time.monotonic() - last_print_time > 2.0: # e.g., 2 seconds
                 print("\rWaiting for data...          ", end="")
            pass # Continue loop
        except struct.error as e:
            print(f"\n[Error] Failed to unpack data: {e}. Data length: {len(data)}. Format: '{STRUCT_FORMAT}'.")
        except Exception as e:
             print(f"\n[Error] An unexpected error occurred: {e}")
             time.sleep(1) # Avoid spamming errors


except KeyboardInterrupt:
    print("\nCtrl+C detected. Shutting down listener.")
finally:
    sock.close()
    print("Socket closed.")
#ifndef BODY_TRANSFORM_H
#define BODY_TRANSFORM_H

#include "Vec3.h"
#include "quat.h"
#include "robot_spec.h" // Includes global state and constants

/**
 * @brief Transforms a target foot position from the Walk Frame to the Leg Frame required by IK.
 *
 * Takes a desired foot position calculated relative to the Walk Frame (gravity-aligned, non-tilting),
 * applies the robot's desired body position offset and orientation, and accounts for the specific
 * leg's origin offset and mounting angle to produce coordinates suitable for the inverse kinematics
 * calculation (`calculateIK`).
 *
 * @param P_foot_walk Input: The target foot position {x,y,z} in the Walk Frame (X=Right, Y=Fwd, Z=Up).
 * @param leg_index Input: The index (0 to LEG_COUNT-1) of the leg being calculated.
 * @param P_foot_leg_ik_input Output: The calculated foot position {x,y,z} to be fed directly into `calculateIK`.
 *                                  - **Origin:** Centered at the specific leg's coxa joint (0,0,0 locally).
 *                                  - **Orientation:** Rotated relative to the robot's body frame by the leg's
 *                                    `legMountingAngle` around the Z-axis. This alignment means:
 *                                      - The local **+Y axis** points in the direction the leg extends horizontally
 *                                        when its coxa angle is 90 degrees (this is the leg's 'forward' direction).
 *                                      - The local **+X axis** points to the 'right' relative to the leg's forward direction.
 *                                      - The local **+Z axis** points 'up' along the coxa joint's rotation axis.
 *                                  This frame ensures `atan2(y, x)` in `calculateIK` correctly computes the coxa angle
 *                                  based on the desired displacement relative to the leg's specific mounting.
 */
inline void transformWalkFrameToLegFrame(
    const Vec3& P_foot_walk,        // Input: Target foot pos calculated by walk_cycle.h (in Walk Frame)
    uint8_t leg_index,              // Input: Index of the leg (0 to LEG_COUNT-1)
    Vec3& P_foot_leg_ik_input)      // Output: Target foot pos for calculateIK (in leg's local frame)
{
    // 1. Get desired body pose relative to Walk Frame (from globals in robot_spec.h)
    const Vec3& P_body_walk = bodyPositionOffset;     // Body origin position in Walk Frame
    const Quaternion& Q_body_walk = bodyOrientation;  // Body orientation relative to Walk Frame

    // 2. Calculate foot position relative to Body origin, expressed in Body Frame axes
    // Vector from body origin to foot in Walk Frame
    Vec3 V_body_to_foot_walk = P_foot_walk - P_body_walk;

    // Inverse of body orientation to rotate from Walk Frame to Body Frame
    // Assumes Q_body_walk used for rotation is normalized. Normalize if unsure.
    // Q_body_walk.normalize(); // Optional: Ensure normalization if input isn't guaranteed
    Quaternion Q_body_walk_inv = Q_body_walk.conjugate();

    // Rotate the vector into the Body Frame
    Vec3 P_foot_body = rotate_vector_by_quaternion(V_body_to_foot_walk, Q_body_walk_inv);

    // 3. Calculate foot position relative to the Leg's coxa origin, still in Body Frame axes
    // Get this leg's coxa joint position relative to body origin (from globals)
    const Vec3& legOrigin_body = legOriginOffset[leg_index];

    // Vector from leg coxa origin to foot target, in Body Frame axes
    Vec3 V_leg_to_foot_body = P_foot_body - legOrigin_body;

    // 4. Rotate the vector from Body Frame axes into the Leg's local IK Frame axes
    // Get this leg's mounting angle (yaw rotation) relative to Body Frame (from globals)
    const float mountAngle = legMountingAngle[leg_index];

    // Create a quaternion representing the inverse rotation (-mountAngle around Z axis)
    // This rotates coordinates from the Body Frame into the Leg's coordinate system expected by IK.
    Quaternion Q_mount_inv = Quaternion::from_axis_angle({0.0f, 0.0f, 1.0f}, -mountAngle);

    // Rotate the vector from Body Frame coords to Leg IK Frame coords
    P_foot_leg_ik_input = rotate_vector_by_quaternion(V_leg_to_foot_body, Q_mount_inv);

    // P_foot_leg_ik_input now holds the coordinates {x,y,z} that should be passed to calculateIK
}


#endif // BODY_TRANSFORM_H
#!/usr/bin/env python3
import sys
import math
import time
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QLabel, QLineEdit, QPushButton, QDoubleSpinBox, QGroupBox, QFormLayout,
    QSizePolicy # ### Added for layout control ###
)
from PySide6.QtCore import Qt, QTimer, Slot, QElapsedTimer
from PySide6.QtGui import QKeyEvent, QCloseEvent, QDoubleValidator

try:
    from hexapod_udp_client import HexapodUDPClient, LEG_COUNT
except ImportError:
    print("Error: Could not find hexapod_udp_client.py or LEG_COUNT definition.")
    sys.exit(1)

# --- Configuration ---
DEFAULT_TARGET_PORT = 5005
DEFAULT_UPDATE_FREQUENCY_HZ = 10.0 # ### Default send rate ###
MIN_UPDATE_FREQUENCY_HZ = 1.0
MAX_UPDATE_FREQUENCY_HZ = 100.0

DEFAULT_LINEAR_SPEED = 5.0
DEFAULT_YAW_RATE = 0.5
DEFAULT_POSE_ADJUST_SPEED_LINEAR = 2.0
DEFAULT_POSE_ADJUST_SPEED_ANGULAR = math.radians(15.0)

# ### ROBOT SPEC CONSTANTS - MUST MATCH YOUR robot_spec.cpp ###
# Example values - replace with your actual robot's configuration
LEG_NAMES = ["BR", "MR", "FR", "BL", "ML", "FL"]
DEFAULT_BASE_POSITIONS = [ # (X, Y, Z) in Walk Frame
    [27.0, -19.0, 0.0], [32.0, 0.0, 0.0], [27.0, 19.0, 0.0], # Right side (0, 1, 2)
    [-27.0, -19.0, 0.0], [-32.0, 0.0, 0.0], [-27.0, 19.0, 0.0] # Left side (3, 4, 5)
]
# Angles (radians) assumed relative to Walk Frame +X (Right)
LEG_MOUNTING_ANGLES = [
    -1 * math.pi / 4.0,  0 * math.pi / 4.0, +1 * math.pi / 4.0, # Right side (0, 1, 2)
    -3 * math.pi / 4.0, +4 * math.pi / 4.0, +3 * math.pi / 4.0  # Left side (3, 4, 5) - Note: +4*pi/4 is just PI
]
# ### END ROBOT SPEC CONSTANTS ###


# ### Simplified Quaternion Class (Keep as before) ###
class Quaternion:
    # ... (Keep the exact same Quaternion class implementation) ...
    def __init__(self, w=1.0, x=0.0, y=0.0, z=0.0):
        self.w = w
        self.x = x
        self.y = y
        self.z = z
        self.normalize()

    def normalize(self):
        mag = math.sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)
        if mag > 1e-9:
            self.w /= mag
            self.x /= mag
            self.y /= mag
            self.z /= mag
        else:
            self.w, self.x, self.y, self.z = 1.0, 0.0, 0.0, 0.0 # Reset to identity
        return self

    def __mul__(self, other):
        w1, x1, y1, z1 = self.w, self.x, self.y, self.z
        w2, x2, y2, z2 = other.w, other.x, other.y, other.z
        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2
        return Quaternion(w, x, y, z)

    @classmethod
    def from_axis_angle(cls, axis_x, axis_y, axis_z, angle_rad):
        half_angle = angle_rad / 2.0
        s = math.sin(half_angle)
        axis_mag = math.sqrt(axis_x**2 + axis_y**2 + axis_z**2)
        if axis_mag < 1e-9: return cls()
        axis_x /= axis_mag
        axis_y /= axis_mag
        axis_z /= axis_mag
        return cls(math.cos(half_angle), axis_x * s, axis_y * s, axis_z * s)

    def to_tuple(self):
        return (self.w, self.x, self.y, self.z)

# --- Main GUI Window ---
class HexapodControllerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Hexapod UDP Controller")
        self.setGeometry(100, 100, 750, 600) # ### Adjusted size ###

        self.hexapod_client = None
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self.update_control_loop)
        self.frame_timer = QElapsedTimer()

        self.keys_pressed = set()
        self.target_linear_speed = DEFAULT_LINEAR_SPEED
        self.target_yaw_rate = DEFAULT_YAW_RATE
        self.pose_adjust_speed_linear = DEFAULT_POSE_ADJUST_SPEED_LINEAR
        self.pose_adjust_speed_angular = DEFAULT_POSE_ADJUST_SPEED_ANGULAR
        self.acceleration_factor = 5.0

        self.current_velocity_x = 0.0
        self.current_velocity_y = 0.0
        self.current_yaw_rate = 0.0
        self.current_body_pos = [0.0, 0.0, 10.0]
        self.current_body_orient = Quaternion(1.0, 0.0, 0.0, 0.0)
        # ### Store current extension values ###
        self.current_leg_extensions = [0.0] * LEG_COUNT
        self._base_pos_needs_recalculation = True # Flag to trigger calculation

        self.last_update_time = 0

        self._init_ui()
        self.update_display()

    def _init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # --- Connection Group (Added Frequency) ---
        connection_group = QGroupBox("Connection & Rate")
        connection_layout = QHBoxLayout(connection_group)
        connection_layout.addWidget(QLabel("Port:"))
        self.port_input = QLineEdit(str(DEFAULT_TARGET_PORT))
        self.port_input.setValidator(QDoubleValidator(1024, 65535, 0))
        self.port_input.setFixedWidth(60)
        connection_layout.addWidget(self.port_input)
        # ### Update Frequency Input ###
        connection_layout.addWidget(QLabel("Update Freq (Hz):"))
        self.update_freq_input = QDoubleSpinBox()
        self.update_freq_input.setRange(MIN_UPDATE_FREQUENCY_HZ, MAX_UPDATE_FREQUENCY_HZ)
        self.update_freq_input.setDecimals(1)
        self.update_freq_input.setSingleStep(1.0)
        self.update_freq_input.setValue(DEFAULT_UPDATE_FREQUENCY_HZ)
        self.update_freq_input.valueChanged.connect(self.update_timer_interval) # ### Connect signal ###
        connection_layout.addWidget(self.update_freq_input)

        self.connect_button = QPushButton("Connect (Broadcast)")
        self.connect_button.clicked.connect(self.toggle_connection)
        connection_layout.addWidget(self.connect_button)
        self.connection_status_label = QLabel("Status: Disconnected")
        connection_layout.addWidget(self.connection_status_label)
        connection_layout.addStretch()
        main_layout.addWidget(connection_group)

        # --- Control & Display Layout ---
        control_display_layout = QHBoxLayout()

        # --- Left Side: Parameters & Inputs ---
        left_widget = QWidget() # ### Use a container widget ###
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0,0,0,0) # Remove margins if needed

        # Target Speeds Input (Same as before)
        speeds_group = QGroupBox("Target Speeds")
        # ... (Keep the speeds group setup exactly as before) ...
        speeds_form_layout = QFormLayout(speeds_group)
        self.target_linear_speed_input = QDoubleSpinBox()
        self.target_linear_speed_input.setRange(0, 50.0); self.target_linear_speed_input.setDecimals(1); self.target_linear_speed_input.setSingleStep(0.5)
        self.target_linear_speed_input.setValue(DEFAULT_LINEAR_SPEED)
        self.target_linear_speed_input.valueChanged.connect(lambda v: setattr(self, 'target_linear_speed', v))
        speeds_form_layout.addRow("Linear Vel (cm/s, WASD):", self.target_linear_speed_input)
        self.target_yaw_rate_input = QDoubleSpinBox()
        self.target_yaw_rate_input.setRange(0, math.pi); self.target_yaw_rate_input.setDecimals(2); self.target_yaw_rate_input.setSingleStep(0.1)
        self.target_yaw_rate_input.setValue(DEFAULT_YAW_RATE)
        self.target_yaw_rate_input.valueChanged.connect(lambda v: setattr(self, 'target_yaw_rate', v))
        speeds_form_layout.addRow("Yaw Rate (rad/s, QE):", self.target_yaw_rate_input)
        self.pose_linear_speed_input = QDoubleSpinBox()
        self.pose_linear_speed_input.setRange(0, 10.0); self.pose_linear_speed_input.setDecimals(1); self.pose_linear_speed_input.setSingleStep(0.1)
        self.pose_linear_speed_input.setValue(DEFAULT_POSE_ADJUST_SPEED_LINEAR)
        self.pose_linear_speed_input.valueChanged.connect(lambda v: setattr(self, 'pose_adjust_speed_linear', v))
        speeds_form_layout.addRow("Pose Lin Spd (cm/s, Arws):", self.pose_linear_speed_input)
        self.pose_angular_speed_input = QDoubleSpinBox()
        self.pose_angular_speed_input.setRange(0, 90.0); self.pose_angular_speed_input.setDecimals(1); self.pose_angular_speed_input.setSingleStep(1.0)
        self.pose_angular_speed_input.setValue(math.degrees(DEFAULT_POSE_ADJUST_SPEED_ANGULAR)) # Display in degrees
        self.pose_angular_speed_input.valueChanged.connect(lambda v: setattr(self, 'pose_adjust_speed_angular', math.radians(v)))
        speeds_form_layout.addRow("Pose Ang Spd (deg/s, IJKLUO):", self.pose_angular_speed_input)
        left_layout.addWidget(speeds_group)

        # Gait Parameters Input (Same as before)
        gait_group = QGroupBox("Gait Parameters")
        # ... (Keep the gait group setup exactly as before) ...
        gait_form_layout = QFormLayout(gait_group)
        self.step_height_input = QDoubleSpinBox()
        self.step_height_input.setRange(0.0, 10.0); self.step_height_input.setDecimals(1); self.step_height_input.setSingleStep(0.1)
        self.step_height_input.setValue(3.0)
        gait_form_layout.addRow("Step Height (cm):", self.step_height_input)
        self.step_freq_input = QDoubleSpinBox()
        self.step_freq_input.setRange(0.1, 5.0); self.step_freq_input.setDecimals(1); self.step_freq_input.setSingleStep(0.1)
        self.step_freq_input.setValue(1.5)
        gait_form_layout.addRow("Step Frequency (Hz):", self.step_freq_input)
        self.duty_factor_input = QDoubleSpinBox()
        self.duty_factor_input.setRange(0.01, 0.99); self.duty_factor_input.setDecimals(2); self.duty_factor_input.setSingleStep(0.05)
        self.duty_factor_input.setValue(0.5)
        gait_form_layout.addRow("Duty Factor:", self.duty_factor_input)
        left_layout.addWidget(gait_group)

        # Instructions (Same as before)
        instructions_group = QGroupBox("Keyboard Controls")
        # ... (Keep the instructions group setup exactly as before) ...
        instructions_layout = QVBoxLayout(instructions_group)
        instructions_text = (
            "W/S: Forward/Backward\nA/D: Strafe Left/Right\n"
            "Q/E: Turn Left/Right\nSPACE: Toggle Walk/Stop\n"
            "--- Body Pose ---\nArrows: Move Body XY\nShift+Arrows: Move Body Z\n"
            "I/K: Pitch\nJ/L: Roll\nU/O: Yaw\n"
            "--- Leg Extensions (See Controls Below) ---" # ### Updated instructions ###
        )
        instructions_label = QLabel(instructions_text)
        instructions_label.setWordWrap(True)
        instructions_layout.addWidget(instructions_label)
        left_layout.addWidget(instructions_group)

        left_layout.addStretch()
        control_display_layout.addWidget(left_widget, 1) # Add container widget

        # --- Center: Leg Extension Controls --- ### NEW SECTION ###
        extension_widget = QWidget()
        extension_layout = QVBoxLayout(extension_widget)
        extension_layout.setContentsMargins(0,0,0,0)

        extension_group = QGroupBox("Leg Extensions (Horizontal Outward, cm)")
        extension_form_layout = QFormLayout(extension_group)
        self.extension_inputs = []
        for i in range(LEG_COUNT):
            ext_input = QDoubleSpinBox()
            ext_input.setRange(-5.0, 10.0) # Allow contraction and extension
            ext_input.setDecimals(1)
            ext_input.setSingleStep(0.1)
            ext_input.setValue(0.0) # Default to no extension
            ext_input.valueChanged.connect(self.mark_base_pos_recalc_needed) # ### Connect signal ###
            self.extension_inputs.append(ext_input)
            extension_form_layout.addRow(f"Leg {i} ({LEG_NAMES[i]}):", ext_input)

        reset_ext_button = QPushButton("Reset All Extensions")
        reset_ext_button.clicked.connect(self.reset_extensions)
        extension_form_layout.addRow(reset_ext_button)

        extension_layout.addWidget(extension_group)
        extension_layout.addStretch()
        control_display_layout.addWidget(extension_widget, 1) # Add extension controls widget


        # --- Right Side: Current State Display ---
        right_widget = QWidget() # ### Use a container widget ###
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0,0,0,0)

        state_group = QGroupBox("Current Target State (Sent to Robot)")
        state_form_layout = QFormLayout(state_group)
        # ... (Keep all the labels self.velocity_x_label etc. as before) ...
        self.velocity_x_label = QLabel("0.00 cm/s")
        self.velocity_y_label = QLabel("0.00 cm/s")
        self.yaw_rate_label = QLabel("0.00 rad/s")
        state_form_layout.addRow("Target Velocity X:", self.velocity_x_label)
        state_form_layout.addRow("Target Velocity Y:", self.velocity_y_label)
        state_form_layout.addRow("Target Yaw Rate:", self.yaw_rate_label)
        self.pos_x_label = QLabel("0.00 cm")
        self.pos_y_label = QLabel("0.00 cm")
        self.pos_z_label = QLabel("10.00 cm")
        state_form_layout.addRow("Body Pos Offset X:", self.pos_x_label)
        state_form_layout.addRow("Body Pos Offset Y:", self.pos_y_label)
        state_form_layout.addRow("Body Pos Offset Z:", self.pos_z_label)
        self.orient_w_label = QLabel("1.000")
        self.orient_x_label = QLabel("0.000")
        self.orient_y_label = QLabel("0.000")
        self.orient_z_label = QLabel("0.000")
        state_form_layout.addRow("Body Orient W:", self.orient_w_label)
        state_form_layout.addRow("Body Orient X:", self.orient_x_label)
        state_form_layout.addRow("Body Orient Y:", self.orient_y_label)
        state_form_layout.addRow("Body Orient Z:", self.orient_z_label)
        self.gait_h_label = QLabel("3.0 cm")
        self.gait_f_label = QLabel("1.5 Hz")
        self.gait_d_label = QLabel("0.50")
        state_form_layout.addRow("Gait Height:", self.gait_h_label)
        state_form_layout.addRow("Gait Freq:", self.gait_f_label)
        state_form_layout.addRow("Gait Duty:", self.gait_d_label)
        self.walk_status_label = QLabel("STOPPED")
        state_form_layout.addRow("Walk Status:", self.walk_status_label)
        # ### Add Base Position Display (Optional but good for debugging) ###
        self.base_pos_labels = []
        for i in range(LEG_COUNT):
             row_layout = QHBoxLayout()
             label_x = QLabel("X: 0.0")
             label_y = QLabel("Y: 0.0")
             label_z = QLabel("Z: 0.0")
             row_layout.addWidget(label_x)
             row_layout.addWidget(label_y)
             row_layout.addWidget(label_z)
             self.base_pos_labels.append({'x': label_x, 'y': label_y, 'z': label_z})
             state_form_layout.addRow(f"Base Pos {i} ({LEG_NAMES[i]}):", row_layout)


        right_layout.addWidget(state_group)
        right_layout.addStretch()
        control_display_layout.addWidget(right_widget, 1)

        main_layout.addLayout(control_display_layout)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    # --- Connection Handling (Updated for Frequency) ---
    @Slot()
    def toggle_connection(self):
        if self.hexapod_client is None:
            try:
                port = int(self.port_input.text())
                freq_hz = self.update_freq_input.value()
                if freq_hz < MIN_UPDATE_FREQUENCY_HZ: # Basic validation
                    raise ValueError("Frequency too low")

                # ### Pass initial base positions to client ###
                self.hexapod_client = HexapodUDPClient(port, use_broadcast=True,
                                                       initial_base_pos=DEFAULT_BASE_POSITIONS)
                # ### Force recalculation on connect ###
                self.recalculate_all_base_positions()

                self.connection_status_label.setText("Status: Connected (Broadcast)")
                self.connection_status_label.setStyleSheet("color: green")
                self.connect_button.setText("Disconnect")
                self.port_input.setEnabled(False)
                self.update_freq_input.setEnabled(False) # ### Disable while connected ###

                interval_ms = int(1000.0 / freq_hz)
                self.update_timer.start(interval_ms)
                self.frame_timer.start()
                self.last_update_time = self.frame_timer.elapsed()
                print(f"Connected. Update interval: {interval_ms} ms ({freq_hz:.1f} Hz)")
            except ValueError as ve:
                 self.connection_status_label.setText(f"Status: Invalid Input ({ve})")
                 self.connection_status_label.setStyleSheet("color: red")
                 self.hexapod_client = None # Ensure client is None
            except Exception as e:
                self.connection_status_label.setText(f"Status: Error - {e}")
                self.connection_status_label.setStyleSheet("color: red")
                if self.hexapod_client: self.hexapod_client.close()
                self.hexapod_client = None
        else:
            # ... (Disconnect logic remains mostly the same) ...
            print("Disconnecting...")
            self.update_timer.stop()
            if self.hexapod_client:
                try: # Send final stop
                    self.hexapod_client.set_walk_command(run=False)
                    self.hexapod_client.set_velocity(0, 0, 0)
                    self.hexapod_client.set_angular_velocity(0)
                    self.hexapod_client.send()
                    time.sleep(0.05)
                    self.hexapod_client.close()
                except Exception as e: print(f"Error sending final stop: {e}")
            self.hexapod_client = None
            self.connection_status_label.setText("Status: Disconnected")
            self.connection_status_label.setStyleSheet("")
            self.connect_button.setText("Connect (Broadcast)")
            self.port_input.setEnabled(True)
            self.update_freq_input.setEnabled(True) # ### Re-enable frequency input ###


    # ### Slot to handle frequency changes ###
    @Slot()
    def update_timer_interval(self):
         # This is called when the frequency input changes value
         # We only adjust the timer IF already connected
         if self.hexapod_client is not None and self.update_timer.isActive():
            try:
                freq_hz = self.update_freq_input.value()
                if freq_hz < MIN_UPDATE_FREQUENCY_HZ:
                     print("[Warning] Frequency set too low, using minimum.")
                     freq_hz = MIN_UPDATE_FREQUENCY_HZ
                     self.update_freq_input.setValue(freq_hz) # Update UI

                interval_ms = int(1000.0 / freq_hz)
                self.update_timer.setInterval(interval_ms)
                print(f"Update interval changed to: {interval_ms} ms ({freq_hz:.1f} Hz)")
            except ValueError:
                print("[Error] Invalid frequency value during update.")
            except ZeroDivisionError:
                 print("[Error] Frequency cannot be zero.")


    # --- Event Handling (keyPress/Release, closeEvent are same) ---
    def keyPressEvent(self, event: QKeyEvent):
        if not event.isAutoRepeat():
            self.keys_pressed.add(event.key())
            if event.key() == Qt.Key.Key_Space:
                if self.hexapod_client:
                    self.hexapod_client.set_walk_command(not self.hexapod_client._walk_running)
                    print(f"Walk Toggled: {'Running' if self.hexapod_client._walk_running else 'Stopped'}")

    def keyReleaseEvent(self, event: QKeyEvent):
        if not event.isAutoRepeat():
            try: self.keys_pressed.remove(event.key())
            except KeyError: pass

    def closeEvent(self, event: QCloseEvent):
        # ... (Keep closeEvent logic exactly as before) ...
        print("Close event triggered.")
        self.update_timer.stop()
        if self.hexapod_client:
            print("Sending final stop command before closing...")
            try:
                self.hexapod_client.set_walk_command(run=False)
                self.hexapod_client.set_velocity(0, 0, 0)
                self.hexapod_client.set_angular_velocity(0)
                self.hexapod_client.send()
                time.sleep(0.05)
                self.hexapod_client.close()
            except Exception as e: print(f"Error during final send/close: {e}")
        event.accept()


    # --- Base Position Calculation --- ### NEW SECTION ###
    @Slot()
    def mark_base_pos_recalc_needed(self):
        """Flags that base positions need recalculation in the next loop."""
        self._base_pos_needs_recalculation = True

    def recalculate_all_base_positions(self):
        """Calculates target XYZ for all legs based on extension inputs."""
        if self.hexapod_client is None: return

        # print("Recalculating base positions...") # Debug print
        for i in range(LEG_COUNT):
            try:
                extension = self.extension_inputs[i].value()
                default_pos = DEFAULT_BASE_POSITIONS[i]
                angle_rad = LEG_MOUNTING_ANGLES[i]

                # Calculate direction vector (outward, relative to Walk Frame +X)
                dir_x = math.cos(angle_rad)
                dir_y = math.sin(angle_rad)

                # Calculate new position
                new_x = default_pos[0] + extension * dir_x
                new_y = default_pos[1] + extension * dir_y
                new_z = default_pos[2] # Keep original Z

                # Update the client's internal state
                self.hexapod_client.set_base_foot_position(i, new_x, new_y, new_z)

            except IndexError:
                print(f"[Error] Index out of bounds during base position calculation for leg {i}.")
            except Exception as e:
                 print(f"[Error] Unexpected error calculating base pos for leg {i}: {e}")

        self._base_pos_needs_recalculation = False # Mark as done for this cycle

    @Slot()
    def reset_extensions(self):
        """Resets all leg extension inputs to 0."""
        print("Resetting leg extensions.")
        for i in range(LEG_COUNT):
            self.extension_inputs[i].setValue(0.0)
        # Recalculation will happen automatically due to valueChanged signal


    # --- Control Loop (Updated) ---
    @Slot()
    def update_control_loop(self):
        if self.hexapod_client is None: return

        current_time = self.frame_timer.elapsed()
        dt = (current_time - self.last_update_time) / 1000.0
        self.last_update_time = current_time
        if dt <= 0: dt = (1000.0 / self.update_freq_input.value()) / 1000.0 # Use configured interval if dt fails

        # --- Recalculate Base Positions if needed --- ### NEW STEP ###
        if self._base_pos_needs_recalculation:
             self.recalculate_all_base_positions()

        # --- Calculate Target Velocities (Same as before) ---
        # ... (Keep velocity calculation and smoothing logic exactly as before) ...
        target_vx = 0.0
        target_vy = 0.0
        target_yaw = 0.0
        if Qt.Key.Key_W in self.keys_pressed: target_vy += self.target_linear_speed
        if Qt.Key.Key_S in self.keys_pressed: target_vy -= self.target_linear_speed
        if Qt.Key.Key_A in self.keys_pressed: target_vx += self.target_linear_speed
        if Qt.Key.Key_D in self.keys_pressed: target_vx -= self.target_linear_speed
        if Qt.Key.Key_Q in self.keys_pressed: target_yaw -= self.target_yaw_rate
        if Qt.Key.Key_E in self.keys_pressed: target_yaw += self.target_yaw_rate
        accel = self.acceleration_factor * dt
        self.current_velocity_x += max(-accel, min(accel, target_vx - self.current_velocity_x))
        self.current_velocity_y += max(-accel, min(accel, target_vy - self.current_velocity_y))
        self.current_yaw_rate   += max(-accel, min(accel, target_yaw - self.current_yaw_rate))
        # Clamping (same as before)
        if abs(self.current_velocity_x) > self.target_linear_speed: self.current_velocity_x = math.copysign(self.target_linear_speed, self.current_velocity_x)
        if abs(self.current_velocity_y) > self.target_linear_speed: self.current_velocity_y = math.copysign(self.target_linear_speed, self.current_velocity_y)
        if abs(self.current_yaw_rate) > self.target_yaw_rate: self.current_yaw_rate = math.copysign(self.target_yaw_rate, self.current_yaw_rate)

        # --- Process Direct Pose Adjustments (Same as before) ---
        # ... (Keep pose adjustment logic exactly as before) ...
        pos_delta_x = 0.0; pos_delta_y = 0.0; pos_delta_z = 0.0
        rot_pitch = 0.0; rot_roll = 0.0; rot_yaw = 0.0
        adjust_lin_step = self.pose_adjust_speed_linear * dt
        adjust_ang_step = self.pose_adjust_speed_angular * dt
        modifiers = QApplication.keyboardModifiers()
        shift_pressed = bool(modifiers & Qt.KeyboardModifier.ShiftModifier)
        if Qt.Key.Key_Up in self.keys_pressed:    pos_delta_y += adjust_lin_step if not shift_pressed else 0; pos_delta_z += adjust_lin_step if shift_pressed else 0
        if Qt.Key.Key_Down in self.keys_pressed:  pos_delta_y -= adjust_lin_step if not shift_pressed else 0; pos_delta_z -= adjust_lin_step if shift_pressed else 0
        if Qt.Key.Key_Left in self.keys_pressed:  pos_delta_x += adjust_lin_step
        if Qt.Key.Key_Right in self.keys_pressed: pos_delta_x -= adjust_lin_step
        if Qt.Key.Key_I in self.keys_pressed: rot_pitch -= adjust_ang_step
        if Qt.Key.Key_K in self.keys_pressed: rot_pitch += adjust_ang_step
        if Qt.Key.Key_J in self.keys_pressed: rot_roll  += adjust_ang_step
        if Qt.Key.Key_L in self.keys_pressed: rot_roll  -= adjust_ang_step
        if Qt.Key.Key_U in self.keys_pressed: rot_yaw   -= adjust_ang_step
        if Qt.Key.Key_O in self.keys_pressed: rot_yaw   += adjust_ang_step
        self.current_body_pos[0] += pos_delta_x
        self.current_body_pos[1] += pos_delta_y
        self.current_body_pos[2] += pos_delta_z
        if abs(rot_yaw) > 1e-6:   self.current_body_orient = self.current_body_orient * Quaternion.from_axis_angle(0, 0, 1, rot_yaw)
        if abs(rot_pitch) > 1e-6: self.current_body_orient = self.current_body_orient * Quaternion.from_axis_angle(1, 0, 0, rot_pitch)
        if abs(rot_roll) > 1e-6:  self.current_body_orient = self.current_body_orient * Quaternion.from_axis_angle(0, 1, 0, rot_roll)
        self.current_body_orient.normalize()

        # --- Update Hexapod Client State (Base Pos already updated if needed) ---
        self.hexapod_client.set_velocity(self.current_velocity_x, self.current_velocity_y)
        self.hexapod_client.set_angular_velocity(self.current_yaw_rate)
        self.hexapod_client.set_gait_params(
            self.step_height_input.value(), self.step_freq_input.value(), self.duty_factor_input.value()
        )
        self.hexapod_client.set_body_position(
            self.current_body_pos[0], self.current_body_pos[1], self.current_body_pos[2]
        )
        orient_tuple = self.current_body_orient.to_tuple()
        self.hexapod_client.set_body_orientation(
            orient_tuple[0], orient_tuple[1], orient_tuple[2], orient_tuple[3], normalize=False
        )

        # --- Send Packet ---
        self.hexapod_client.send()

        # --- Update UI Display ---
        self.update_display()


    # --- UI Update (Added Base Pos Display) ---
    def update_display(self):
        if self.hexapod_client is None:
             self.walk_status_label.setText("STOPPED (Disconnected)")
             return

        # ... (Update velocity, pose, gait labels as before) ...
        self.velocity_x_label.setText(f"{self.current_velocity_x:.2f} cm/s")
        self.velocity_y_label.setText(f"{self.current_velocity_y:.2f} cm/s")
        self.yaw_rate_label.setText(f"{self.current_yaw_rate:.3f} rad/s")
        self.pos_x_label.setText(f"{self.current_body_pos[0]:.2f} cm")
        self.pos_y_label.setText(f"{self.current_body_pos[1]:.2f} cm")
        self.pos_z_label.setText(f"{self.current_body_pos[2]:.2f} cm")
        orient_tuple = self.current_body_orient.to_tuple()
        self.orient_w_label.setText(f"{orient_tuple[0]:.3f}")
        self.orient_x_label.setText(f"{orient_tuple[1]:.3f}")
        self.orient_y_label.setText(f"{orient_tuple[2]:.3f}")
        self.orient_z_label.setText(f"{orient_tuple[3]:.3f}")
        self.gait_h_label.setText(f"{self.step_height_input.value():.1f} cm")
        self.gait_f_label.setText(f"{self.step_freq_input.value():.1f} Hz")
        self.gait_d_label.setText(f"{self.duty_factor_input.value():.2f}")
        self.walk_status_label.setText("RUNNING" if self.hexapod_client._walk_running else "STOPPED")
        self.walk_status_label.setStyleSheet("color: green" if self.hexapod_client._walk_running else "color: red")

        # ### Update base position display labels ###
        if hasattr(self.hexapod_client, 'base_foot_pos'):
            for i in range(LEG_COUNT):
                try:
                    pos = self.hexapod_client.base_foot_pos[i]
                    self.base_pos_labels[i]['x'].setText(f"X: {pos[0]:.1f}")
                    self.base_pos_labels[i]['y'].setText(f"Y: {pos[1]:.1f}")
                    self.base_pos_labels[i]['z'].setText(f"Z: {pos[2]:.1f}")
                except (IndexError, KeyError):
                    pass # Handle potential errors if labels/data mismatch


# --- Main Execution ---
if __name__ == "__main__":
    # ... (Keep main execution block as before) ...
    print("Starting Hexapod GUI Controller...")
    print("Remember to run this script with Administrator privileges on Windows for broadcast.")
    app = QApplication(sys.argv)
    # ### Ensure LEG_COUNT matches between GUI and Client ###
    if LEG_COUNT != len(LEG_NAMES) or LEG_COUNT != len(DEFAULT_BASE_POSITIONS) or LEG_COUNT != len(LEG_MOUNTING_ANGLES):
         print("[FATAL ERROR] Mismatch in LEG_COUNT definitions!")
         sys.exit(1)
    window = HexapodControllerGUI()
    window.show()
    sys.exit(app.exec())
//hexapod_proj.ino
// Suggested servo limits (optional)
#define SERVOMIN  175 //-71 degrees (assume -76 degrees)
#define SERVOMAX  535 //81 degrees (Assume 76 degrees)
#define SERVOMIDDLE 355
#define SERVO_FREQ 50

#define OSSIAN_HEMMA

#include <WiFi.h>
#include <WiFiUdp.h>
// --- Global Variables ---
WiFiUDP udp;

#include "utils.h"


#include "serial_remote.h"
#include "servo_wave.h"
#include "set_pos.h"
#include "walkcycle_serial.h"
#include "walkcycle_remote.h"

// Program states
enum ProgramState {
  MAIN_MENU,
  SERIAL_CONTROL,
  WAVE_PROGRAM,
  IK_PROGRAM,
  WALKCYCLE_SERIAL,
  WALKCYCLE_REMOTE,
  // Add more program states here as you create them
};

ProgramState currentState = MAIN_MENU;

void printMainMenu() {
  Serial.println("\n===== Main Menu =====");
  Serial.println("1 - Serial Servo Control");
  Serial.println("2 - Sinus Wave");
  Serial.println("3 - Inverse kinematics");
  Serial.println("4 - Walkcycle Serial");
  Serial.println("5 - Walkcycle Remote");
  Serial.println("====================");
}



void setup() {
  Serial.begin(115200);
  Serial.printf("Connecting to %s ", ssid);
  WiFi.begin(ssid, password);
  // ... (WiFi connection loop - same as before) ...
  int wifi_retries = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    wifi_retries++;
    if (wifi_retries > 20) {
        Serial.println("\nWiFi Connection Failed! Halting.");
        while(1) { delay(1000); }
    }
  }
  Serial.println(" Connected!");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  setupPwm();

  printMainMenu();
}


void handleMainMenu() {
  if (Serial.available() > 0) {
    Serial.println("enter: ");
    String input = Serial.readStringUntil('\n');
    input.trim();
    
    char input_char;
    if (input.length() > 0)
      input_char = input.charAt(0);
    else input_char = '\n';
    
    switch (input_char) {
      case '1':
        currentState = SERIAL_CONTROL;
        setup_serial_control();
        break;
        
      case '2':
        currentState = WAVE_PROGRAM;
        setupWaveProgram();
        break;
        
      case '3':
        currentState = IK_PROGRAM;
        setupIKPostitioning();
        break;
      case '4':
        currentState = WALKCYCLE_SERIAL;
        setupWalkcycleSerial();
        break;
      case '5':
        currentState = WALKCYCLE_REMOTE;
        setupWalkcycleRemote();
        break;
        
      case 'X':
        // Already in main menu
        Serial.println("Already in main menu");
        printMainMenu();
        break;
        
      default:
        Serial.println("Invalid selection");
        printMainMenu();
        break;
    }
  }
}

void stateMachine() {
switch (currentState) {
    case MAIN_MENU:
      handleMainMenu();
      break;
      
    case SERIAL_CONTROL:
      if (!update_serial()) { // If update_serial returns false, exit to main menu
        Serial.println("update_serial exited, returning to menu");
        currentState = MAIN_MENU;
        printMainMenu();
      }
      break;

    case WAVE_PROGRAM:
      if (!updateWaveProgram()) { // If update_serial returns false, exit to main menu
        Serial.println("updateWaveProgram exited, returning to menu");
        currentState = MAIN_MENU;
        printMainMenu();
      }
      break;

    case IK_PROGRAM:
      if (!IKpositioning()) { // If update_serial returns false, exit to main menu
        Serial.println("updateIKProgram exited, returning to menu");
        currentState = MAIN_MENU;
        printMainMenu();
      }
      break;

    case WALKCYCLE_SERIAL:
      if (!walkcycleSerialUpdate()) { // If update_serial returns false, exit to main menu
        Serial.println("walkCycleSerial exited, returning to menu");
        currentState = MAIN_MENU;
        printMainMenu();
      }
      break;

    case WALKCYCLE_REMOTE:
      if (!walkcycleRemoteUpdate()) { // If update_serial returns false, exit to main menu
        Serial.println("walkCycleRemote exited, returning to menu");
        currentState = MAIN_MENU;
        printMainMenu();
      }
      break;
      
    // Add more program cases here as you create them
  }
}

void loop() {
  stateMachine();
  #ifdef OSSIAN_HEMMA
    // Check if WiFi is connected before attempting to send
    if (WiFi.status() == WL_CONNECTED && (millis() % 20) == 0) {
        udp.beginPacket(angleBroadcastIp, angleBroadcastPort);
        // Send the raw bytes of the entire latestServoAngles array
        udp.write((uint8_t*)latestServoAngles, sizeof(latestServoAngles));
        udp.endPacket();
    }
  #endif // OSSIAN_HEMMA
}
# hexapod_udp_client.py

import socket
import struct
import time
import math

# ### Define LEG_COUNT - should match ESP32 ###
LEG_COUNT = 6

class HexapodUDPClient:
    """
    A client class to send FullControlPacket UDP datagrams to the ESP32 hexapod.
    Manages packet structure, sequence numbers, timestamps, and UDP sending.
    """
    # --- Updated Packet Format including base foot positions ---
    # '<' = little-endian
    # Metadata: I Q I (16 bytes)
    # Control State: B (1 byte)
    # Locomotion: fff f fff (7 floats = 28 bytes)
    # Body Pose: fff ffff (7 floats = 28 bytes)
    # Base Foot Pos: f * (LEG_COUNT * 3) (18 floats = 72 bytes)
    _PACKET_FORMAT = '<I Q I B fff f fff fff ffff' + 'f' * (LEG_COUNT * 3)
    _PACKET_SIZE = struct.calcsize(_PACKET_FORMAT) # 16 + 1 + 28 + 28 + 72 = 145 bytes
    _PACKET_IDENTIFIER = 0xFEEDF00D

    _FLAG_WALK_RUNNING = (1 << 0)

    def __init__(self, target_port: int, use_broadcast: bool = True, initial_base_pos=None): # ### Added initial_base_pos ###
        if struct.calcsize(self._PACKET_FORMAT) != self._PACKET_SIZE:
             raise ValueError(f"Packet format size mismatch! Expected {self._PACKET_SIZE}, got {struct.calcsize(self._PACKET_FORMAT)}")

        print(f"Initializing UDP Client. Expected packet size: {self._PACKET_SIZE} bytes") # ### Moved print ###
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sequence_number = 0

        if use_broadcast:
            try:
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                print("Broadcast enabled on socket.")
            except OSError as e:
                print(f"[Error] Could not enable broadcast on socket: {e}. Try running as Admin.")
                # Don't necessarily exit, maybe it works anyway on some systems or user handles it
            self.target_address = ('255.255.255.255', target_port)
            print(f"Target address set to BROADCAST:{target_port}")
        else:
            raise NotImplementedError("Unicast mode requires providing a specific target IP.")

        # --- Initialize internal state variables ---
        self._identifier = self._PACKET_IDENTIFIER
        self._timestamp_ms = 0
        self._walk_running = False
        self.velocity_x = 0.0
        self.velocity_y = 0.0
        self.velocity_z = 0.0
        self.angular_velocity_yaw = 0.0
        self.step_height = 3.0
        self.step_frequency = 1.0
        self.duty_factor = 0.5
        self.body_position_x = 0.0
        self.body_position_y = 0.0
        self.body_position_z = 10.0
        self.body_orientation_w = 1.0
        self.body_orientation_x = 0.0
        self.body_orientation_y = 0.0
        self.body_orientation_z = 0.0

        # ### Store base foot positions (initialize with defaults from GUI) ###
        if initial_base_pos and len(initial_base_pos) == LEG_COUNT and all(len(p) == 3 for p in initial_base_pos):
             self.base_foot_pos = [list(pos) for pos in initial_base_pos] # Ensure mutable lists
        else:
             # Fallback default if none provided (should match ESP32 defaults ideally)
             print("[Warning] Initial base positions not provided or invalid format. Using fallback.")
             self.base_foot_pos = [[15.0, -13.0, 0.0], [20.0, 0.0, 0.0], [15.0, 13.0, 0.0],
                                   [-15.0, -13.0, 0.0], [-20.0, 0.0, 0.0], [-15.0, 13.0, 0.0]]

        print(f"Hexapod UDP Client initialized.")
        print(f"Expected packet size: {self._PACKET_SIZE} bytes")

    def _get_timestamp_ms(self) -> int:
        """Returns the current time in milliseconds."""
        return int(time.time() * 1000)

    def set_walk_command(self, run: bool):
        """Sets the walk cycle running state."""
        self._walk_running = bool(run)

    def set_velocity(self, vx: float, vy: float, vz: float = 0.0):
        """
        Sets the desired linear body velocity relative to the Walk Frame.
        Args:
            vx: Sideways velocity (cm/s, +X Right).
            vy: Forward/Backward velocity (cm/s, +Y Forward).
            vz: Vertical velocity (cm/s, +Z Up). Defaults to 0.
        """
        self.velocity_x = float(vx)
        self.velocity_y = float(vy)
        self.velocity_z = float(vz)

    def set_angular_velocity(self, yaw_rate: float):
        """
        Sets the desired angular body velocity (turning speed) relative to the Walk Frame.
        Args:
            yaw_rate: Turning speed around the Z axis (radians/s, +Yaw is Left Turn).
        """
        self.angular_velocity_yaw = float(yaw_rate)

    def set_gait_params(self, height: float, frequency: float, duty: float):
        """
        Sets the walk gait parameters.
        Args:
            height: Step height in cm.
            frequency: Step frequency in Hz.
            duty: Duty factor (0.01 to 0.99 recommended).
        """
        self.step_height = float(height)
        self.step_frequency = float(frequency)
        # Clamp duty factor to a reasonable range to match ESP32 receiver clamp
        self.duty_factor = max(0.01, min(0.99, float(duty)))

    def set_body_position(self, x: float, y: float, z: float):
        """
        Sets the desired body position offset relative to the Walk Frame origin.
        Args:
            x: X offset (cm, +X Right).
            y: Y offset (cm, +Y Forward).
            z: Z offset (ride height) (cm, +Z Up).
        """
        self.body_position_x = float(x)
        self.body_position_y = float(y)
        self.body_position_z = float(z)

    def set_body_orientation(self, w: float, x: float, y: float, z: float, normalize: bool = True):
        """
        Sets the desired body orientation relative to the Walk Frame axes using a quaternion.
        Args:
            w, x, y, z: Components of the quaternion.
            normalize: If True (default), normalize the quaternion before storing.
                       It's crucial that the quaternion sent is (close to) normalized.
        """
        qw, qx, qy, qz = float(w), float(x), float(y), float(z)
        if normalize:
            mag = math.sqrt(qw**2 + qx**2 + qy**2 + qz**2)
            if mag > 1e-6: # Avoid division by zero
                qw /= mag
                qx /= mag
                qy /= mag
                qz /= mag
            else: # Invalid quaternion (magnitude zero), set to identity
                qw, qx, qy, qz = 1.0, 0.0, 0.0, 0.0
                print("[Warning] Invalid zero-magnitude quaternion provided. Setting to identity.")

        self.body_orientation_w = qw
        self.body_orientation_x = qx
        self.body_orientation_y = qy
        self.body_orientation_z = qz
    def set_base_foot_position(self, leg_index: int, x: float, y: float, z: float):
        """Updates the target base foot position for a single leg."""
        if 0 <= leg_index < LEG_COUNT:
            self.base_foot_pos[leg_index][0] = float(x)
            self.base_foot_pos[leg_index][1] = float(y)
            self.base_foot_pos[leg_index][2] = float(z)
        else:
            print(f"[Error] Invalid leg index {leg_index} in set_base_foot_position.")


    def pack_data(self) -> bytes:
        """Packs the current state into the binary format for sending."""
        self.sequence_number += 1
        self._timestamp_ms = self._get_timestamp_ms()

        control_flags = 0
        if self._walk_running:
            control_flags |= self._FLAG_WALK_RUNNING

        # ### Flatten the base_foot_pos list ###
        flat_base_pos = [coord for pos in self.base_foot_pos for coord in pos]
        if len(flat_base_pos) != LEG_COUNT * 3:
             print(f"[Error] Internal base_foot_pos has incorrect size! Expected {LEG_COUNT*3}, got {len(flat_base_pos)}")
             # Handle error - maybe send previous valid state or zeros?
             # For now, let struct.pack potentially fail below.
             flat_base_pos = [0.0] * (LEG_COUNT * 3) # Fallback to zeros

        try:
            # Pack data in the order defined by _PACKET_FORMAT
            args_to_pack = [
                # Metadata
                self._identifier, self._timestamp_ms, self.sequence_number,
                # Control State
                control_flags,
                # Locomotion Control
                self.velocity_x, self.velocity_y, self.velocity_z,
                self.angular_velocity_yaw, self.step_height, self.step_frequency, self.duty_factor,
                # Body Pose Control
                self.body_position_x, self.body_position_y, self.body_position_z,
                self.body_orientation_w, self.body_orientation_x, self.body_orientation_y, self.body_orientation_z
            ]
            # Append the flattened base positions
            args_to_pack.extend(flat_base_pos)

            packed_data = struct.pack(self._PACKET_FORMAT, *args_to_pack)

            # Sanity check size after packing
            if len(packed_data) != self._PACKET_SIZE:
                 print(f"[Error] Packed data size unexpected! Expected {self._PACKET_SIZE}, got {len(packed_data)}")

            return packed_data
        except struct.error as e:
            print(f"[Error] Failed to pack data: {e}")
            print("Current values:")
            print(f"  ID: {self._identifier}, TS: {self._timestamp_ms}, Seq: {self.sequence_number}")
            print(f"  Flags: {control_flags}")
            print(f"  LinVel: ({self.velocity_x}, {self.velocity_y}, {self.velocity_z})")
            print(f"  AngVel: {self.angular_velocity_yaw}")
            print(f"  Gait: ({self.step_height}, {self.step_frequency}, {self.duty_factor})")
            print(f"  Pos: ({self.body_position_x}, {self.body_position_y}, {self.body_position_z})")
            print(f"  Orient: ({self.body_orientation_w}, {self.body_orientation_x}, {self.body_orientation_y}, {self.body_orientation_z})")
            return None # Indicate packing failure

    def send(self):
        """
        Packs the current state and sends it as a UDP packet.
        """
        packed_bytes = self.pack_data()
        if packed_bytes:
            try:
                self.socket.sendto(packed_bytes, self.target_address)
            except socket.error as e:
                print(f"[Error] Socket error sending packet: {e}")
            # except Exception as e:
            #     print(f"[Error] Unexpected error sending packet: {e}")

    def close(self):
        """Closes the UDP socket."""
        print("Closing UDP socket.")
        self.socket.close()

# --- Example Usage ---
if __name__ == "__main__":
    # Replace with your ESP32's IP address
    ESP32_IP = "255.255.255.255" #just broadcast
    ESP32_PORT = 5005

    print("Starting Hexapod UDP Client Example...")
    client = HexapodUDPClient(ESP32_IP, ESP32_PORT)
    time.sleep(0.1)
    try:
        # Example: Make the hexapod walk forward slowly for 5 seconds
        print("Commanding walk forward...")
        client.set_walk_command(run=True)
        client.set_velocity(vx=0.0, vy=3.0, vz=0.0) # 3 cm/s forward
        client.set_angular_velocity(yaw_rate=0.0)
        client.set_body_position(x=0, y=0, z=12) # Set ride height to 12cm
        # Keep default orientation (identity quaternion)
        client.set_gait_params(height=3.0, frequency=1.5, duty=0.5)

        start_time = time.time()
        while time.time() - start_time < 5.0:
            client.send()
            print(f"Sent packet Seq={client.sequence_number}")
            time.sleep(0.55) # Send packets at ~20 Hz

        # Example: Make the hexapod turn left while stopped for 3 seconds
        print("Commanding turn left...")
        client.set_velocity(vx=0.0, vy=0.0, vz=0.0) # Stop linear movement
        client.set_angular_velocity(yaw_rate=0.5)  # 0.5 rad/s yaw rate (left turn)

        start_time = time.time()
        while time.time() - start_time < 3.0:
            client.send()
            print(f"Sent packet Seq={client.sequence_number}")
            time.sleep(0.05)

        # Example: Stop walking
        print("Commanding stop...")
        client.set_walk_command(run=False)
        client.set_velocity(vx=0.0, vy=0.0, vz=0.0)
        client.set_angular_velocity(yaw_rate=0.0)
        # Send stop command a few times to ensure it's received
        for _ in range(10):
            client.send()
            print(f"Sent packet Seq={client.sequence_number}")
            time.sleep(0.05)

    except KeyboardInterrupt:
        print("\nCaught Ctrl+C, stopping...")
    finally:
        # Ensure stop command is sent on exit
        print("Sending final stop command...")
        client.set_walk_command(run=False)
        client.set_velocity(vx=0.0, vy=0.0, vz=0.0)
        client.set_angular_velocity(yaw_rate=0.0)
        # Send a few times for good measure
        for _ in range(5):
            client.send()
            time.sleep(0.02)
        client.close()
        print("Client closed.")
// ik.h
#ifndef IK_H
#define IK_H

#include "utils.h"
#include <math.h>
#include "robot_spec.h"

bool calculateIK(uint8_t leg, float x, float y, float z, float& coxaAngle, float& femurAngle, float& tibiaAngle) {
  const float lC = COXA_LENGTH;
  const float lF = FEMUR_LENGTH;
  const float lT = TIBIA_LENGTH;

  // Calculate coxa angle (yaw)
  coxaAngle = atan2(y, x);
  if (coxaAngle < COXA_MIN_ANGLE + servo_center_angle[0] || coxaAngle > COXA_MAX_ANGLE + servo_center_angle[0]) {
    Serial.print("Coxa angle out of range(");
    Serial.print(coxaAngle / M_PI * 180.0f);
      Serial.println(" degrees)");

      Serial.print("Range: ");
      Serial.print((COXA_MIN_ANGLE + servo_center_angle[0])*180.0/M_PI);
      Serial.print(" to ");
      Serial.println((COXA_MAX_ANGLE + servo_center_angle[0])*180.0/M_PI);
      
      Serial.print("Target coords: ");
      Serial.print(x);
      Serial.print(", ");
      Serial.print(y);
      Serial.print(", ");
      Serial.println(z);
    return false;
  }

  //distance between femur joint and foot
  float h; {
    float hhor = sqrt(x*x + y*y) - lC;
    h = sqrt(hhor*hhor + z*z);
    
    // Check if position is reachable
    if (h > (lF + lT) || h < fabs(lF - lT)) {
      Serial.println("Target position unreachable!");
      return false;
    }
  }

  //femurAngle
  {
    float A = acos(
      (lF*lF + h*h - lT*lT) / 
      (2*lF*h)
    );

    float ah = asin(z/h);
    femurAngle = A + ah;
    femurAngle = fmod(femurAngle + M_PI, 2 * M_PI) - M_PI; //remapping it into the correct range -pi to +pi
    
    if (femurAngle < FEMUR_MIN_ANGLE + servo_center_angle[1] || femurAngle > FEMUR_MAX_ANGLE + servo_center_angle[1]) {
      Serial.print("Femur angle out of range(");
      Serial.print(femurAngle / M_PI * 180.0f);
      Serial.println(" degrees)");

      Serial.print("Range: ");
      Serial.print((FEMUR_MIN_ANGLE + servo_center_angle[1])*180.0/M_PI);
      Serial.print(" to ");
      Serial.println((FEMUR_MAX_ANGLE + servo_center_angle[1])*180.0/M_PI);
      
      Serial.print("Target coords: ");
      Serial.print(x);
      Serial.print(", ");
      Serial.print(y);
      Serial.print(", ");
      Serial.println(z);
      return false;
    }
  }

  //tibiaAngle
  {
    float C = -acos( //Law of cosines
      (lF*lF + lT*lT - h*h) / 
      (2*lF*lT)
    );

    tibiaAngle = M_PI - C;
    tibiaAngle = fmod(tibiaAngle + M_PI, 2 * M_PI) - M_PI; //remapping it into the correct range -pi to +pi

    if (tibiaAngle < TIBIA_MIN_ANGLE + servo_center_angle[2] || tibiaAngle > TIBIA_MAX_ANGLE + servo_center_angle[2]) {
      Serial.print("Tibia angle out of range(");
      Serial.print(tibiaAngle / M_PI * 180.0f);
      Serial.println(" degrees)");

      Serial.print("Range: ");
      Serial.print((TIBIA_MIN_ANGLE + servo_center_angle[2])*180.0/M_PI);
      Serial.print(" to ");
      Serial.println((TIBIA_MAX_ANGLE + servo_center_angle[2])*180.0/M_PI);
      
      Serial.print("Target coords: ");
      Serial.print(x);
      Serial.print(", ");
      Serial.print(y);
      Serial.print(", ");
      Serial.println(z);
      return false;
    }
  }


  return true;
}


void moveLegToTarget(uint8_t leg, const Vec3& target_leg_ik, bool log = false) {
    float coxa_rad, femur_rad, tibia_rad;

    if (calculateIK(leg, target_leg_ik.x, target_leg_ik.y, target_leg_ik.z, coxa_rad, femur_rad, tibia_rad)) {
        // IK successful, send angles to servos
        setAngleRadians(LEG_SERVOS[leg][0], coxa_rad);
        setAngleRadians(LEG_SERVOS[leg][1], femur_rad);
        setAngleRadians(LEG_SERVOS[leg][2], tibia_rad);

        // Original logging (optional, can be combined with FK logging)
        // if (log) { ... }

    } else {
        // IK failed
        if (log) {
            Serial.print("[IK Failed] Leg "); Serial.print(leg_names[leg]); Serial.print(" ("); Serial.print(leg); Serial.print(")");
            Serial.print(" -> Target LegIK: "); target_leg_ik.print(""); // Use Vec3 print helper
        }
    }
}

#endif
// packets.h (Should already be like this from previous steps)
#ifndef PACKETS_H
#define PACKETS_H

#include <stdint.h>

// --- Packet Identifiers ---
#define FULL_CONTROL_PACKET_IDENTIFIER 0xFEEDF00D

#pragma pack(push, 1)
struct FullControlPacket {
    // --- Metadata (16 bytes) ---
    uint32_t identifier;
    uint64_t timestampMs;
    uint32_t sequenceNumber;

    // --- Control State (1 byte) ---
    uint8_t  controlFlags; // Bit 0: walkCycleRunning

    // --- Locomotion Control (28 bytes) ---
    float    velocityX;
    float    velocityY;
    float    velocityZ;
    float    angularVelocityYaw;
    float    stepHeight;
    float    stepFrequency;
    float    dutyFactor;

    // --- Body Pose Control (28 bytes) ---
    float    bodyPositionOffsetX;
    float    bodyPositionOffsetY;
    float    bodyPositionOffsetZ;
    float    bodyOrientationW;
    float    bodyOrientationX;
    float    bodyOrientationY;
    float    bodyOrientationZ;

    // --- Base Foot Positions (Walk Frame) (6 legs * 3 coords * 4 bytes/float = 72 bytes) ---
    float    baseFootPosXYZ[6 * 3];

};
#pragma pack(pop)

// Total Size: 16 + 1 + 28 + 28 + 72 = 145 bytes
static_assert(sizeof(FullControlPacket) == 145, "FullControlPacket size mismatch. Expected 145 bytes.");

// --- Bit Masks for controlFlags ---
#define FLAG_WALK_RUNNING  (1 << 0)

#endif // PACKETS_H
#ifndef QUAT_H
#define QUAT_H

#include <math.h>    // For sqrt, sin, cos
#include "Vec3.h"    // Include the Vec3 definition

// Quaternion Structure
struct Quaternion {
    float w = 1.0f; // Real part
    float x = 0.0f; // i component
    float y = 0.0f; // j component
    float z = 0.0f; // k component

    // Default constructor (initializes to identity)
    Quaternion() = default;

    // Constructor with explicit values
    Quaternion(float w_val, float x_val, float y_val, float z_val)
        : w(w_val), x(x_val), y(y_val), z(z_val) {}

    // --- Basic Properties ---

    // Get the identity quaternion
    static Quaternion identity() {
        return Quaternion(1.0f, 0.0f, 0.0f, 0.0f);
    }

    // Calculate the magnitude (norm) of the quaternion
    inline float norm() const {
        return sqrtf(w*w + x*x + y*y + z*z);
    }

    // --- Operations ---

    // Calculate the conjugate of the quaternion
    // For unit quaternions (used for rotation), conjugate is the inverse.
    inline Quaternion conjugate() const {
        return Quaternion(w, -x, -y, -z);
    }

    // Return a normalized version of the quaternion (unit quaternion)
    // Rotations should always use unit quaternions.
    inline Quaternion normalized() const {
        float n = norm();
        if (n < 1e-9f) { // Avoid division by zero or near-zero
            fprintf(stderr, "Warning: Normalizing near-zero quaternion. Returning identity.\n");
            return Quaternion::identity();
        }
        float inv_norm = 1.0f / n;
        return Quaternion(w * inv_norm, x * inv_norm, y * inv_norm, z * inv_norm);
    }

    // Normalize the quaternion in-place
    inline void normalize() {
        float n = norm();
        if (n < 1e-9f) {
            fprintf(stderr, "Warning: Normalizing near-zero quaternion in-place. Setting to identity.\n");
            w = 1.0f; x = 0.0f; y = 0.0f; z = 0.0f; // Set to identity
            return;
        }
        float inv_norm = 1.0f / n;
        w *= inv_norm;
        x *= inv_norm;
        y *= inv_norm;
        z *= inv_norm;
    }

    // --- Creation from Axis-Angle ---
    // Creates a quaternion representing a rotation of angle_rad around axis.
    // Assumes axis is a non-zero vector (doesn't need to be normalized beforehand).
    static Quaternion from_axis_angle(const Vec3& axis, float angle_rad) {
        float half_angle = angle_rad * 0.5f;
        float s = sinf(half_angle);
        float c = cosf(half_angle);

        // Normalize the axis vector
        Vec3 normalized_axis = axis.normalized(); // Uses Vec3::normalized()

        return Quaternion(
            c,
            normalized_axis.x * s,
            normalized_axis.y * s,
            normalized_axis.z * s
        );
    }
};

// --- Standalone Functions ---

// Quaternion multiplication (Hamilton product: q_result = q_left * q_right)
// Note: Order matters! Corresponds to applying q_right rotation then q_left.
inline Quaternion operator*(const Quaternion& q_left, const Quaternion& q_right) {
    return Quaternion(
        q_left.w * q_right.w - q_left.x * q_right.x - q_left.y * q_right.y - q_left.z * q_right.z,  // New w
        q_left.w * q_right.x + q_left.x * q_right.w + q_left.y * q_right.z - q_left.z * q_right.y,  // New x
        q_left.w * q_right.y - q_left.x * q_right.z + q_left.y * q_right.w + q_left.z * q_right.x,  // New y
        q_left.w * q_right.z + q_left.x * q_right.y - q_left.y * q_right.x + q_left.z * q_right.w   // New z
    );
}

// Rotate a 3D vector by a unit quaternion
// Assumes q is normalized (unit quaternion).
// Implements v' = q * v * conjugate(q) using the efficient formula:
// v' = v + 2 * cross(q.xyz, cross(q.xyz, v) + q.w * v)
inline Vec3 rotate_vector_by_quaternion(const Vec3& v, const Quaternion& q) {
    Vec3 q_vec = {q.x, q.y, q.z}; // The vector part of the quaternion

    // Calculate the cross products using standalone cross function from Vec3.h
    Vec3 uv = cross(q_vec, v);    // cross(q.xyz, v)
    Vec3 uuv = cross(q_vec, uv);  // cross(q.xyz, cross(q.xyz, v))

    // Calculate the scaled vectors (using Vec3 operators)
    Vec3 scaled_uv = uv * (2.0f * q.w);
    Vec3 scaled_uuv = uuv * 2.0f;

    // Combine them (using Vec3 operator)
    return v + scaled_uv + scaled_uuv;
}


#endif // QUAT_H
# ESP32-S3 Hexapod Control Firmware

## Project Goal

Develop a versatile C++ firmware for an 18-DOF hexapod robot using an ESP32-S3 microcontroller. This project enables remote control via UDP/WiFi, featuring a layered kinematic system that allows independent control over the robot body's pose (position and orientation) relative to its base locomotion path.

## Hardware

*   **Microcontroller:** Xiao ESP32-S3
*   **Servo Motors:** 18x High-Torque Hobby Servos (e.g., 35kg-cm), 3 per leg (Coxa, Femur, Tibia).
*   **Servo Driver:** 2x Adafruit PCA9685 16-Channel PWM Servo Driver boards (connected via I2C).
*   **Connectivity:** WiFi (for UDP remote control).
*   **(Optional):** PC or other device for sending UDP control packets (Python GUI controller provided: `hexapod_controller_gui.py`).

## Software Architecture

The firmware utilizes a state machine (`hexapod_proj.ino`) to switch between operating modes. The core of the remote control and walking logic relies on a layered kinematic approach with distinct coordinate frames:

1.  **State Machine (`hexapod_proj.ino`):** Manages overall program flow and mode selection via Serial Monitor.
2.  **Coordinate Frames & Kinematics:** (See details below)
    *   **Walk Frame:** The primary reference frame for locomotion.
    *   **Body Frame:** Attached to the robot's physical chassis.
    *   **Leg Frame:** Local frame for each leg's IK calculation.
    *   **Walk Cycle (`walkcycle.h`):** Generates target foot positions within the **Walk Frame**.
    *   **Body Transformation (`body_transform.h`):** Transforms targets from the **Walk Frame** to the **Leg Frame**, incorporating desired body pose.
    *   **Inverse Kinematics (`ik.h`):** Calculates joint angles needed to reach the target in the **Leg Frame**.
3.  **Low-Level Control (`utils.h`):** Handles I2C communication with PCA9685 drivers and converts angles to PWM signals.
4.  **Math Utilities (`Vec3.h`, `quat.h`):** Vector and Quaternion math libraries.
5.  **Configuration (`robot_spec.h`, `robot_spec.cpp`):** **CRITICAL:** Defines robot dimensions, joint limits, servo mappings, and global state variables.
6.  **Control Interfaces:** Headers implementing logic for specific modes (e.g., `walkcycle_remote.h`, `set_pos.h`).
7.  **Packet Definition (`packets.h`):** Defines the structure of UDP control packets.

## Coordinate Systems Explained

Understanding these frames (as used in the code) is crucial:

1.  **Walk Frame:**
    *   The primary coordinate system for locomotion planning, used internally by `walkcycle.h`.
    *   **Origin & Orientation:** Conceptually, its origin lies on the ground plane below the robot's center. The frame's position and yaw orientation change relative to the external environment based on the commanded `bodyVelocity` and `bodyAngularVelocityYaw`. However, it always remains level (does not pitch or roll relative to the external vertical, Z-Up).
    *   **Command Interpretation:** Commanded `bodyVelocity` and `bodyAngularVelocityYaw` define the instantaneous velocity (linear and angular) that a *stance foot must counteract within the Walk Frame* to remain stationary relative to the external environment.
    *   **Key Use:**
        *   `baseFootPositionWalk[i]` coordinates represent the neutral foot landing targets, fixed *within this Walk Frame's coordinate system*.
        *   The `walkcycle.h` stance phase calculates foot motion *within this frame* needed to achieve external stationarity based on the velocity commands.
        *   The Body Frame's pose (`bodyPositionOffset`, `bodyOrientation`) is defined *relative* to this frame, allowing the physical body to be positioned and oriented independently of the base locomotion defined by the Walk Frame's conceptual movement.

2.  **Body Frame:**
    *   **Origin:** Attached to a reference point on the robot's chassis (e.g., geometric center).
    *   **Orientation:** Fixed relative to the chassis (+Y Forward, +X Right, +Z Up along the chassis).
    *   **Relationship:** Its desired instantaneous position and 3D orientation (yaw, pitch, roll) *relative to the Walk Frame* are specified by `bodyPositionOffset` and `bodyOrientation`. This allows independent control of body pose (tilting, shifting, yawing relative to the direction of travel).

3.  **Leg Frame:**
    *   **Origin:** At the specific leg's coxa joint (hip).
    *   **Orientation:** Rotated relative to the **Body Frame** by the leg's `legMountingAngle` (defined in `robot_spec.cpp`). This aligns the Leg Frame's axes appropriately for the `calculateIK` function (e.g., +Y points horizontally outward along the leg's neutral direction).
    *   **Input Frame:** This is the coordinate system expected by `calculateIK`.

## Kinematic Flow (Remote Walk Mode)

1.  **UDP Commands Received:** The ESP32 receives target values via `FullControlPacket`:
    *   `bodyVelocity`, `bodyAngularVelocityYaw`: Define the instantaneous velocity a stance foot must counteract *within the Walk Frame* to remain externally stationary.
    *   `bodyPositionOffset`, `bodyOrientation`: Define the **Body Frame's** target pose relative to the **Walk Frame**.
    *   `baseFootPositionWalk[i]`: Define neutral foot targets *within the **Walk Frame***.
    *   Gait parameters (`stepHeight`, `stepFrequency`, `dutyFactor`).
    *   Control flags (`walkCycleRunning`).
2.  **Walk Cycle Calculation (`walkcycle.h`):**
    *   Operates entirely *within* the **Walk Frame**.
    *   **Stance Phase:** Calculates the required foot velocity *within the Walk Frame* based *directly* on commanded `bodyVelocity` and `bodyAngularVelocityYaw` to counteract the relative environmental motion, aiming for external stationarity. Updates the foot's **Walk Frame** coordinates (`leg.currentPosition`).
    *   **Swing Phase:** Interpolates the foot from its lift-off position (`swingStartPosition`) to the neutral target (`baseFootPositionWalk[i]`), both defined as coordinates *within the **Walk Frame***. Adds vertical lift (`stepHeight`).
    *   **Output:** Target foot position `P_foot_walk` (in Walk Frame coordinates).
3.  **Body Transformation (`body_transform.h`):**
    *   Takes `P_foot_walk` (Walk Frame coords) as input.
    *   Uses `bodyPositionOffset` and `bodyOrientation` (defining the Body Frame's pose relative to the Walk Frame) to transform the coordinates into the **Body Frame's** reference system.
    *   Uses `legOriginOffset` and `legMountingAngle` (defining the Leg Frame's pose relative to the Body Frame) to transform the coordinates into the **Leg Frame**.
    *   **Output:** Target foot position `P_foot_leg_ik_input` (in Leg Frame coordinates).
4.  **Inverse Kinematics (`ik.h`):**
    *   Takes `P_foot_leg_ik_input` (Leg Frame coords) for a specific leg.
    *   Calculates the required Coxa, Femur, and Tibia joint angles (radians).
5.  **Servo Command (`utils.h`):**
    *   Converts calculated angles to PWM pulse widths based on calibration (`SERVOMIN`/`MAX`) and servo mapping (`LEG_SERVOS`).
    *   Sends commands to the appropriate PCA9685 driver channel.

## Operating Modes (Selectable via Main Menu)

*   **`SERIAL_CONTROL` (`serial_remote.h`):** Low-level servo pulse control via Serial.
*   **`WAVE_PROGRAM` (`servo_wave.h`):** Simple sine wave servo demo.
*   **`IK_PROGRAM` (`set_pos.h`):** Interactive IK testing via Serial (targets relative to Leg Frame).
*   **`WALKCYCLE_SERIAL` (`walkcycle_serial.h`):** Deprecated/Simplified walk control via Serial (may not fully support the current kinematic model).
*   **`WALKCYCLE_REMOTE` (`walkcycle_remote.h`):** **Primary Mode.** Full remote control via UDP using the layered kinematics described above.

## Key Files

*   `hexapod_proj.ino`: Main sketch, state machine.
*   `walkcycle.h`: Core walk cycle logic (operates in Walk Frame).
*   `body_transform.h`: Coordinate transformation (Walk Frame -> Leg Frame).
*   `ik.h`: Inverse kinematics calculation.
*   `robot_spec.h`/`.cpp`: **Robot physical configuration & global state variables.**
*   `Vec3.h` / `quat.h`: Vector and Quaternion math.
*   `utils.h`: PCA9685 driver setup, angle/pulse conversions.
*   `packets.h`: UDP packet structure definition.
*   `walkcycle_remote.h`: UDP handling and remote mode logic.
*   (Other mode headers: `set_pos.h`, `serial_remote.h`, `servo_wave.h`)

## Configuration (CRITICAL!)

You **MUST** configure `robot_spec.cpp` for your specific robot build:

1.  **`LEG_COUNT`:** Set to 6 for a standard hexapod.
2.  **Leg Dimensions:** Define `COXA_LENGTH`, `FEMUR_LENGTH`, `TIBIA_LENGTH` (in cm).
3.  **Joint Limits:** Define `*_MIN_ANGLE`, `*_MAX_ANGLE` for Coxa, Femur, Tibia (in **radians**). Ensure these are respected by IK and potentially PWM conversion.
4.  **`legOriginOffset[LEG_COUNT]`:** Measure the {X, Y, Z} position (cm) of each coxa joint relative to your chosen **Body Frame** origin (+X Right, +Y Fwd, +Z Up along chassis). **Incorrect values here will break body transformations.**
5.  **`legMountingAngle[LEG_COUNT]`:** Determine the physical yaw angle (**radians**, counter-clockwise positive) of each leg's neutral direction relative to the **Body Frame's** +Y axis. Ensure consistency between C++ and any controlling GUI.
6.  **`LEG_SERVOS[LEG_COUNT][3]`:** Map the logical leg/joint (0:Coxa, 1:Femur, 2:Tibia) to the correct physical PCA9685 output channel index (0-17 overall). Double-check against your wiring and the I2C addresses used in `utils.h` (0x40, 0x41).
7.  **Initial State:** Set reasonable initial values for `bodyPositionOffset` (e.g., `{0, 0, 15.0}` for 15cm ride height relative to Walk Frame) and `baseFootPositionWalk` (neutral stance coordinates in **Walk Frame**).
8.  **Edit `walkcycle_remote.h` (if using):**
    *   Set your WiFi `ssid` and `password`.
    *   Adjust `localUdpPort` if needed (must match sender).

## How to Use

1.  **Hardware Setup:** Connect servos, drivers, and ESP32 correctly (check I2C pins in `utils.h`). Provide appropriate power.
2.  **Configure:** **Critically review and edit `robot_spec.cpp` and `walkcycle_remote.h`.**
3.  **Compile & Upload:** Open `hexapod_proj.ino` in Arduino IDE or PlatformIO. Install `Adafruit PWM Servo Driver Library`. Compile and upload.
4.  **Run:** Open Serial Monitor (115200 baud). Select `WALKCYCLE_REMOTE` (or other modes).
5.  **Control (Remote Mode):** Run the companion Python script (`hexapod_controller_gui.py`) or your own UDP sender application to send `FullControlPacket` datagrams to the ESP32's IP address on the configured port. Use the GUI or script to command velocities, pose, and gait parameters.
6.  **Exit Mode:** Usually 'X' via Serial Monitor returns to the main menu.

## Adding New Modes

Follow the pattern in `hexapod_proj.ino`: Add enum, include header, add menu option/handler, add state machine case calling your mode's `update_X()` function.

## Current Limitations & Future Work

*   **Kinematic Model Accuracy:** The sequential application of linear and rotational effects in the Walk Frame stance phase provides good accuracy for typical loop rates (>60Hz) and walking speeds. Extremely high combined speeds/rotations might introduce minor errors.
*   **Gait Flexibility:** Walk cycle uses a simple time-based phase offset (tripod). Developing more sophisticated gaits (ripple, wave) and smooth transitions would be beneficial.
*   **Sensor Integration:** No IMU feedback for balance/stabilization or foot sensors for terrain adaptation.
*   **Error Handling/Safety:** Minimal checks for self-collision, motor limits, etc. Robust safety features should be added.
*   **IK Singularities:** Basic IK doesn't explicitly handle singularities near workspace limits.

## Dependencies

*   Arduino ESP32 Board Support Package
*   `Adafruit PWM Servo Driver Library` (Install via Arduino Library Manager)
*   `WiFi` (ESP32 Built-in)
*   `Wire` (ESP32 Built-in for I2C)
#include "robot_spec.h"
#define OSSIAN_HEMMA

#ifdef OSSIAN_HEMMA
const float COXA_LENGTH  = 8.0f; // Length from hip to knee joint
const float FEMUR_LENGTH = 9.0; // Length from knee to ankle joint
const float TIBIA_LENGTH = 10.5; // Length from ankle to foot
#else
// Leg mechanical parameters (in cm)
const float COXA_LENGTH  = 7.0f; // Length from hip to knee joint
const float FEMUR_LENGTH = 10.0; // Length from knee to ankle joint
const float TIBIA_LENGTH = 11.6; // Length from ankle to foot
#endif
// Joint angle limits (in radians)
const float COXA_MIN_ANGLE  =  (-60 * M_PI / 180.0);
const float COXA_MAX_ANGLE  =   (60 * M_PI / 180.0);
const float FEMUR_MIN_ANGLE =  (-70 * M_PI / 180.0);
const float FEMUR_MAX_ANGLE =   (70 * M_PI / 180.0);
const float TIBIA_MIN_ANGLE =  (-70 * M_PI / 180.0);
const float TIBIA_MAX_ANGLE =   (70 * M_PI / 180.0);

// ... other lengths and angle limits ...

//Leg names
const char* leg_names[LEG_COUNT] = {"Back Right", "Mid Right", "Front Right", "Back Left", "Mid Left", "Front Left"};


float latestServoAngles[LEG_COUNT * 3] = {0};

// Default neutral foot positions in Walk Frame {X, Y, Z} (in cm)
// Relative to the point on the ground directly below the body center. (walk frame)
#ifdef OSSIAN_HEMMA
Vec3 baseFootPositionWalk[LEG_COUNT] = {
    { 27.0f, -19.0f, 0.0f}, // Leg 0 (BR): Example - Back Right
    { 32.0f,   0.0f, 0.0f}, // Leg 1 (CR): Example - Center Right
    { 27.0f,  19.0f, 0.0f}, // Leg 2 (FR): Example - Front Right
    {-27.0f, -19.0f, 0.0f}, // Leg 3 (BL): Example - Back Left
    {-32.0f,   0.0f, 0.0f}, // Leg 4 (CL): Example - Center Left
    {-27.0f,  19.0f, 0.0f}  // Leg 5 (FL): Example - Front Left
};
#else
Vec3 baseFootPositionWalk[LEG_COUNT] = {
    { 15.0f, -13.0f, 0.0f}, // Leg 0 (BR): Example - Back Right
    { 20.0f,   0.0f, 0.0f}, // Leg 1 (CR): Example - Center Right
    { 15.0f,  13.0f, 0.0f}, // Leg 2 (FR): Example - Front Right
    {-15.0f, -13.0f, 0.0f}, // Leg 3 (BL): Example - Back Left
    {-20.0f,   0.0f, 0.0f}, // Leg 4 (CL): Example - Center Left
    {-15.0f,  13.0f, 0.0f}  // Leg 5 (FL): Example - Front Left
};
#endif

// Servo channel assignments per leg [leg][joint: 0=coxa, 1=femur, 2=tibia]
const uint8_t LEG_SERVOS[LEG_COUNT][3] = {
  { 9, 10, 11},   // Leg 0 (BR)
  {12, 13, 14},   // Leg 1 (CR)
  {15, 16, 17},   // Leg 2 (FR)
  { 0,  1,  2},   // Leg 3 (BL)
  { 3,  4,  5},   // Leg 4 (CL)
  { 6,  7,  8},   // Leg 5 (FL)
};
#ifdef OSSIAN_HEMMA
const Vec3 legOriginOffset[LEG_COUNT] = {
    {   12.0f,   -10.0f, 0.0f}, // Leg 0(BR)
    {   12.0f,     0.0f, 0.0f}, // Leg 1(CR)
    {   12.0f,    10.0f, 0.0f}, // Leg 2(FR)
    {  -12.0f,   -10.0f, 0.0f}, // Leg 3(BL)
    {  -12.0f,     0.0f, 0.0f}, // Leg 4(CL)
    {  -12.0f,    10.0f, 0.0f}  // Leg 5(FL)
};
#else
#endif

const float legMountingAngle[LEG_COUNT] = {
    -1*M_PI / 4.0f, // Leg 0(BR)
     0*M_PI / 4.0f, // Leg 1(CR)
    +1*M_PI / 4.0f, // Leg 2(FR)
    
    -3*M_PI / 4.0f, // Leg 3(BL)
    +4*M_PI / 4.0f, // Leg 4(CL)
    +3*M_PI / 4.0f  // Leg 5(FL)
};

const float servo_center_angle[3] = {
    0.0f, 0.0f, -45.0f * M_PI / 180.0f, // Coxa, Femur, Tibia
};

// Define global state variables (initial values)
Vec3 bodyPositionOffset = {0.0f, 0.0f, 17.0f}; // Start 15cm above walk frame origin
Quaternion bodyOrientation = Quaternion::identity();
Vec3 bodyVelocity = {0.0f, 0.0f, 0.0f}; // Initialize to zero velocity
float bodyAngularVelocityYaw = 0.0f;

#ifndef ROBOT_SPEC_H
#define ROBOT_SPEC_H

#include "Vec3.h"
#include "quat.h"

// --- Constants ---
#define LEG_COUNT 6 // Make sure this matches LEG_SERVOS etc.

// Leg mechanical parameters (in cm) - Moved from ik_servo.h
extern const float COXA_LENGTH;
extern const float FEMUR_LENGTH;
extern const float TIBIA_LENGTH;

// Joint angle limits (in radians) - Moved from ik_servo.h
extern const float COXA_MIN_ANGLE;
extern const float COXA_MAX_ANGLE;
extern const float FEMUR_MIN_ANGLE;
extern const float FEMUR_MAX_ANGLE;
extern const float TIBIA_MIN_ANGLE;
extern const float TIBIA_MAX_ANGLE;

//Leg names
extern const char* leg_names[LEG_COUNT];

// Leg Geometry & Configuration
// Position of each leg's coxa joint relative to the Body Frame origin (X=Right, Y=Fwd, Z=Up)
extern const Vec3 legOriginOffset[LEG_COUNT];
// Mounting angle (yaw/Z-rotation) of each leg relative to the Body Frame's Y-axis (radians)
// Example: 0 = straight forward/backward, +PI/4 = 45deg right, -PI/4 = 45deg left
extern const float legMountingAngle[LEG_COUNT];
extern const float servo_center_angle[3];

// Servo channel assignments per leg [leg][joint: 0=coxa, 1=femur, 2=tibia]
// Maps logical leg/joint to the physical PCA9685 channel (0-15 range, board dependent)
extern const uint8_t LEG_SERVOS[LEG_COUNT][3];

// --- Global State Variables ---
// Desired body pose relative to the Walk Frame (Walk Frame: X=Right, Y=Fwd, Z=Up, fixed orientation)
extern float latestServoAngles[LEG_COUNT * 3];
extern Vec3 bodyPositionOffset;    // Body center translation from Walk Frame origin
extern Quaternion bodyOrientation; // Body orientation relative to Walk Frame axes
extern Vec3 bodyVelocity; // Desired body velocity relative to the Walk Frame (cm/s)
extern float bodyAngularVelocityYaw;
    

// --- Default Stance Positions ---
// Neutral position for each foot relative to the Walk Frame origin (X=Right, Y=Fwd, Z=Up)
// Used as the center point for stepping calculations. Z=0 usually means foot on the ground.
extern Vec3 baseFootPositionWalk[LEG_COUNT];


#endif // ROBOT_SPEC_H

    
#include "utils.h"

// Movement parameters
#define DEFAULT_SPEED 5       // Steps per movement iteration
#define DEFAULT_SMOOTHNESS 10 // Delay between steps (ms)

struct ServoChannel {
  uint16_t currentPulse;
  uint16_t targetPulse;
};

ServoChannel channels[16]; // All 16 channels

uint8_t movementSpeed = DEFAULT_SPEED;
uint8_t smoothness = DEFAULT_SMOOTHNESS;


void centerAllServos() {
  for (uint8_t i = 0; i < 16; i++) {
    channels[i].currentPulse = SERVOMIDDLE;
    channels[i].targetPulse = SERVOMIDDLE;
    
    // Directly set the hardware pulse
    setAnglePulse(i, SERVOMIDDLE); 
  }
  Serial.println("All servos centered (Pulse: " + String(SERVOMIDDLE) + ")");
}

void setup_serial_control(){
  Serial.println("Xiao ESP32-S3 16-Channel Servo Control");
  Serial.println("Commands (angles in degrees, roughly -76 to +76):");
  Serial.println("M[channel],[angle] - Move servo (e.g., M5,30.5)"); // Updated help text
  Serial.println("P[angle] - Move all servos (e.g., P-15.0)");       // Updated help text
  Serial.println("S[speed] - Set movement speed (1-50)");
  Serial.println("D[delay] - Set smoothness delay (1-50ms)");
  Serial.println("C - Center all servos (Angle: 0.0)"); // Updated help text
  Serial.println("X - Exit this mode and return to main menu");
}

bool processSerialCommands() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    input.trim();
    
    if (input.length() > 0) {
      char command = input.charAt(0);
      // Keep the rest of the string, including potential negative signs for angles
      String valueString = input.substring(1); 
      
      switch (command) {
        case 'X':
          Serial.println("Exiting serial control mode.");
          return false; // Signal to exit the mode/loop

        case 'M': // Move command: M[channel],[angle_degrees]
          {
            int commaIndex = valueString.indexOf(',');
            if (commaIndex > 0) {
              // Extract channel number
              String channelStr = valueString.substring(0, commaIndex);
              uint8_t channel = channelStr.toInt(); 

              // Extract angle value
              String angleStr = valueString.substring(commaIndex + 1);
              float angle_degrees = angleStr.toFloat(); 

              if (channel < 16) {
                // Calculate the target pulse from the angle
                uint16_t target_pulse = get_pulse_from_angle_degrees(0, angle_degrees); //TODO! this is not great since i have hardcoded the servo_idx

                // Set the target pulse for smooth movement
                channels[channel].targetPulse = target_pulse; 

                // Print confirmation with both angle and resulting pulse
                Serial.print("Moving channel ");
                Serial.print(channel);
                Serial.print(" to angle ");
                Serial.print(angle_degrees, 2); // Print angle with 2 decimal places
                Serial.print(" degrees (Pulse: ");
                Serial.print(target_pulse);
                Serial.println(")");
              } else {
                Serial.println("Invalid channel (0-15)");
              }
            } else {
              Serial.println("Invalid format. Use M[channel],[angle_degrees]");
            }
          }
          break;
        
        case 'P': // Move all servos: P[angle_degrees]
          {
            float angle_degrees = valueString.toFloat();
            uint16_t target_pulse = get_pulse_from_angle_degrees(0, angle_degrees); //TODO! this is not great since i have hardcoded the servo_idx

            for(int i = 0; i < 16; i++) {
              channels[i].targetPulse = target_pulse;
            }

            Serial.print("Moving all channels to angle ");
            Serial.print(angle_degrees, 2); // Print angle with 2 decimal places
            Serial.print(" degrees (Pulse: ");
            Serial.print(target_pulse);
            Serial.println(")");
          }
          break;
      
        case 'S': // Set speed: S[speed]
          {
            // Use valueString directly here as it contains the number after 'S'
            uint8_t speed = valueString.toInt(); 
            if (speed >= 1 && speed <= 50) {
              movementSpeed = speed;
              Serial.print("Movement speed set to ");
              Serial.println(movementSpeed);
            } else {
              Serial.println("Speed must be between 1-50");
            }
          }
          break;
          
        case 'D': // Set smoothness delay: D[delay]
          {
             // Use valueString directly here as it contains the number after 'D'
            uint8_t delayTime = valueString.toInt();
            if (delayTime >= 1 && delayTime <= 50) {
              smoothness = delayTime;
              Serial.print("Smoothness delay set to ");
              Serial.print(smoothness);
              Serial.println("ms");
            } else {
              Serial.println("Delay must be between 1-50ms");
            }
          }
          break;
          
        case 'C': // Center all servos
          centerAllServos(); // This already sets targetPulse and currentPulse to SERVOMIDDLE
          break;
          
        default:
          Serial.println("Unknown command");
          break;
      }
      
    }
    return true; // Command processed (or no command received), continue loop
  }
  return true; // No command available, continue loop
}

// moveServosSmoothly remains the same as it works with pulse values
void moveServosSmoothly() {
  bool changed = false; // Optional: check if any servo actually moved
  for (uint8_t i = 0; i < 16; i++) {
    if (channels[i].currentPulse != channels[i].targetPulse) {
      changed = true;
      // Calculate direction and step
      int16_t difference = channels[i].targetPulse - channels[i].currentPulse;
      
      // Determine the step size, ensuring we don't overshoot
      int16_t step;
      if (abs(difference) <= movementSpeed) {
          step = difference; // Take the final step
      } else {
          step = (difference > 0) ? movementSpeed : -movementSpeed;
      }
      
      channels[i].currentPulse += step;
      
      // Clamp currentPulse just in case (though step calculation should prevent overshoot)
      // channels[i].currentPulse = constrain(channels[i].currentPulse, SERVOMIN, SERVOMAX); 
      // Note: get_pulse_from_angle already clamps, so targetPulse is safe.
      // Clamping here might be redundant unless there's a bug elsewhere.

      setAnglePulse(i, channels[i].currentPulse); // Use the utility function to set PWM
    }
  }
  // Only delay if a servo actually moved or if smoothness > 0
  if (changed || smoothness > 0) { 
      delay(smoothness);
  }
}

// Main loop function for serial control mode
bool update_serial() {
  // First, process any incoming commands which might update targetPulse
  bool continueRunning = processSerialCommands(); 
  if (!continueRunning) {
    return false; // User entered 'X'
  }

  // Then, move servos smoothly towards their targets
  moveServosSmoothly(); 

  return true; // Continue running serial control mode
}
// wave_servo.h
#ifndef WAVE_SERVO_H
#define WAVE_SERVO_H

#include "utils.h"

// Wave parameters
#define DEFAULT_WAVE_SPEED 5       // Speed multiplier
#define DEFAULT_WAVE_AMPLITUDE 180  // Default amplitude (half of full range)

struct WaveChannel {
  bool active;
  float phase;
  uint16_t center;
  uint16_t amplitude;
};

WaveChannel waveChannels[18]; // All 16 channels
uint8_t waveSpeed = DEFAULT_WAVE_SPEED;
bool waveRunning = false;
unsigned long lastWaveUpdate = 0;

void setupWaveProgram() {
  Serial.println("\n==== Servo Wave Program ====");
  Serial.println("Commands:");
  Serial.println("M[channel] - Toggle motor (e.g., M5)");
  Serial.println("A - Toggle all motors");
  Serial.println("S[speed] - Set wave speed (1-20)");
  Serial.println("C[center] - Set center position (175-535)");
  Serial.println("V[amplitude] - Set amplitude (1-180)");
  Serial.println("G - Go/Start waving");
  Serial.println("B - Break/Stop waving");
  Serial.println("X - Exit to main menu");
  Serial.println("========================");
  
  // Initialize all channels to inactive
  for (uint8_t i = 0; i < 16; i++) {
    waveChannels[i].active = false;
    waveChannels[i].phase = 0;
    waveChannels[i].center = SERVOMIDDLE;
    waveChannels[i].amplitude = DEFAULT_WAVE_AMPLITUDE;
  }
  
  waveRunning = false;
}

bool processWaveCommands() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    input.trim();
    
    if (input.length() > 0) {
      char command = input.charAt(0);
      input = input.substring(1); // Remove command character
      
      switch (command) {
        case 'X': // Exit program
          waveRunning = false;
          Serial.println("Exiting wave program");
          return false;
          
        case 'B': // Break/Stop
          waveRunning = false;
          Serial.println("Waving stopped");
          break;
          
        case 'G': // Go/Start
          waveRunning = true;
          lastWaveUpdate = millis();
          Serial.println("Waving started");
          break;
          
        case 'M': // Toggle motor
          {
            uint8_t channel = input.toInt();
            if (channel < 18) {
              waveChannels[channel].active = !waveChannels[channel].active;
              Serial.print("Channel ");
              Serial.print(channel);
              Serial.print(" is now ");
              Serial.println(waveChannels[channel].active ? "active" : "inactive");
            }
          }
          break;
          
        case 'A': // Toggle all motors
          {
            bool newState = !waveChannels[0].active; // Toggle based on first channel
            for (uint8_t i = 0; i < 18
            ; i++) {
              waveChannels[i].active = newState;
            }
            Serial.print("All channels are now ");
            Serial.println(newState ? "active" : "inactive");
          }
          break;
          
        case 'S': // Set speed
          {
            uint8_t speed = input.toInt();
            if (speed >= 1 && speed <= 20) {
              waveSpeed = speed;
              Serial.print("Wave speed set to ");
              Serial.println(waveSpeed);
            } else {
              Serial.println("Speed must be between 1-20");
            }
          }
          break;
          
        case 'C': // Set center position
          {
            uint16_t center = input.toInt();
            if (center >= SERVOMIN && center <= SERVOMAX) {
              for (uint8_t i = 0; i < 18; i++) {
                if (waveChannels[i].active) {
                  waveChannels[i].center = center;
                }
              }
              Serial.print("Active channels center set to ");
              Serial.println(center);
            } else {
              Serial.println("Center must be between 175-535");
            }
          }
          break;
          
        case 'V': // Set amplitude
          {
            uint16_t amplitude = input.toInt();
            if (amplitude >= 1 && amplitude <= 180) {
              for (uint8_t i = 0; i < 18; i++) {
                if (waveChannels[i].active) {
                  waveChannels[i].amplitude = amplitude;
                }
              }
              Serial.print("Active channels amplitude set to ");
              Serial.println(amplitude);
            } else {
              Serial.println("Amplitude must be between 1-180");
            }
          }
          break;
          
        default:
          Serial.println("Unknown command");
          break;
      }
    }
  }
  return true;
}

void updateWave() {
  if (!waveRunning) return;
  
  unsigned long currentTime = millis();
  float deltaTime = (currentTime - lastWaveUpdate) / 1000.0; // Convert to seconds
  lastWaveUpdate = currentTime;
  
  for (uint8_t i = 0; i < 18; i++) {
    if (waveChannels[i].active) {
      // Update phase based on speed
      waveChannels[i].phase += deltaTime * waveSpeed * 0.1;
      if (waveChannels[i].phase > 2 * M_PI) {
        waveChannels[i].phase -= 2 * M_PI;
      }
      
      // Calculate sinusoidal position
      float sinValue = sin(waveChannels[i].phase);
      uint16_t pulse = waveChannels[i].center + (sinValue * waveChannels[i].amplitude);
      pulse = constrain(pulse, SERVOMIN, SERVOMAX);
      
      setAnglePulse(i, pulse);
    }
  }
}

bool updateWaveProgram() {
  updateWave();
  return processWaveCommands();
}

#endif
#ifndef SET_POS_H
#define SET_POS_H

#include "ik.h"

bool ikRunning = false;
uint8_t currentLeg = 0;
Vec3 legTargets[LEG_COUNT];
bool legActive[LEG_COUNT] = {true, true, true, true, true, true};

void setupIKPostitioning(){
  ikRunning = false;

  Serial.println("\n==== Leg IK Control Program ====");
  Serial.println("Commands:");
  Serial.println("L[leg] - Select leg (0-3)");
  Serial.println("A - Toggle all legs");
  Serial.println("x[value] - Set x position (cm)");
  Serial.println("y[value] - Set y position (cm)");
  Serial.println("z[value] - Set z position (cm)");
  Serial.println("M - Move to current coordinates");
  Serial.println("G - Go/Start continuous IK updates");
  Serial.println("B - Break/Stop IK updates");
  Serial.println("H - Home position (retracted)");
  Serial.println("E - Extended position");
  Serial.println("D - Display current positions");
  Serial.println("X - Exit to main menu");
  Serial.println("========================");
}

bool processIKCommands() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    input.trim();

    if (input.length() > 0) {
      char command = input.charAt(0);
      input = input.substring(1);

      switch (command) {
        case 'X':
          ikRunning = false;
          Serial.println("Exiting IK program");
          return false;

        case 'B':
          ikRunning = false;
          Serial.println("IK updates stopped");
          break;

        case 'G':
          ikRunning = true;
          Serial.println("IK updates started");
          break;

        case 'L':
          {
            uint8_t leg = input.toInt();
            if (leg < LEG_COUNT) {
              currentLeg = leg;
              Serial.print("Selected leg ");
              Serial.println(leg);
            }
          }
          break;

        case 'A':
          {
            bool newState = !legActive[0];
            for (uint8_t i = 0; i < LEG_COUNT; i++) {
              legActive[i] = newState;
            }
            Serial.print("All legs are now ");
            Serial.println(newState ? "active" : "inactive");
          }
          break;

        case 'x':
          legTargets[currentLeg].x = input.toFloat();
          Serial.print("Leg ");
          Serial.print(currentLeg);
          Serial.print(" X set to ");
          Serial.println(legTargets[currentLeg].x);
          break;

        case 'y':
          legTargets[currentLeg].y = input.toFloat();
          Serial.print("Leg ");
          Serial.print(currentLeg);
          Serial.print(" Y set to ");
          Serial.println(legTargets[currentLeg].y);
          break;

        case 'z':
          legTargets[currentLeg].z = input.toFloat();
          Serial.print("Leg ");
          Serial.print(currentLeg);
          Serial.print(" Z set to ");
          Serial.println(legTargets[currentLeg].z);
          break;

        case 'M':
          moveLegToTarget(currentLeg, legTargets[currentLeg]);
          break;

        case 'H':
          for (uint8_t i = 0; i < LEG_COUNT; i++) {
            legTargets[i] = {25, 0, 0};
            if (legActive[i]) moveLegToTarget(i, legTargets[i]);
          }
          Serial.println("All legs moved to home position");
          break;

        case 'E':
          for (uint8_t i = 0; i < LEG_COUNT; i++) {
            legTargets[i] = {0, COXA_LENGTH + FEMUR_LENGTH, -TIBIA_LENGTH};
            if (legActive[i]) moveLegToTarget(i, legTargets[i]);
          }
          Serial.println("All legs moved to extended position");
          break;

        case 'D':
          for (uint8_t i = 0; i < LEG_COUNT; i++) {
            Serial.print("Leg ");
            Serial.print(i);
            Serial.print(": X=");
            Serial.print(legTargets[i].x);
            Serial.print(" Y=");
            Serial.print(legTargets[i].y);
            Serial.print(" Z=");
            Serial.println(legTargets[i].z);
          }
          break;

        default:
          Serial.println("Unknown command");
          break;
      }
    }
  }
  return true;
}

bool IKpositioning() {
  if (ikRunning) {
    for (uint8_t i = 0; i < LEG_COUNT; i++) {
      if (legActive[i]) moveLegToTarget(i, legTargets[i]);
    }
  }

  return processIKCommands();
}

#endif
#ifndef UTILS_H
#define UTILS_H

// Define I2C pins for Xiao ESP32-S3
#define I2C_SDA 5
#define I2C_SCL 6

#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
Adafruit_PWMServoDriver pwm0 = Adafruit_PWMServoDriver(0x40, Wire);
Adafruit_PWMServoDriver pwm1 = Adafruit_PWMServoDriver(0x41, Wire);

//#include "Vec3.h" //not needed du eto quat including it
#include "quat.h"
#include "robot_spec.h"
#include <math.h>

void setupPwm(){
  Wire.begin(I2C_SDA, I2C_SCL);

  if (!pwm0.begin()) {
    Serial.println("PCA9685 0 not found! Servo control will not work.");
  }
  if (!pwm1.begin()) {
    Serial.println("PCA9685 1 not found! Servo control will not work.");
  }
  
  pwm0.setOscillatorFrequency(27000000);
  pwm1.setOscillatorFrequency(27000000);
  pwm0.setPWMFreq(SERVO_FREQ);
  pwm1.setPWMFreq(SERVO_FREQ);
  delay(10);
}

float mapf(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float clampf(float val, float min, float max){
  if (val < min) val = min;
  if (val > max) val = max;
  return val;
}

float clampmapf(float x, float in_min, float in_max, float out_min, float out_max){
  float val = mapf(x, in_min, in_max, out_min, out_max);
  if (val > out_max) val = out_max;
  if (val < out_min) val = out_min;
  return val;
}

uint16_t get_pulse_from_angle_degrees(uint8_t servo_idx, float angle){
  return(clampmapf(angle - servo_center_angle[servo_idx % 3] * 180.0f / M_PI, -76.0f, 76.0f, SERVOMIN, SERVOMAX));
}
uint16_t get_pulse_from_angle_radians(uint8_t servo_idx, float angle){
  return(clampmapf(angle - servo_center_angle[servo_idx % 3], -M_PI * (76.0/180.0), M_PI * (76.0/180.0), SERVOMIN, SERVOMAX));
}

void setAnglePulse(uint8_t servo_idx, uint16_t pulse){
  #ifdef OSSIAN_HEMMA
  latestServoAngles[servo_idx] = (((float)(pulse - SERVOMIN) * (2.0f * (76.0f * M_PI / 180.0f)) / (float)(SERVOMAX - SERVOMIN)) - (76.0f * M_PI / 180.0f))
                                  + servo_center_angle[servo_idx % 3] * 180.0f / M_PI;
  #endif
  #ifndef OSSIAN_HEMMA
  if(!(servo_idx / 9)){
    pwm0.setPWM(servo_idx, 0, pulse);
  }
  else{
    pwm1.setPWM(servo_idx - 9, 0, pulse);
  }
  #endif
}

void setAngleDegrees(uint8_t servo_idx, float angle){
  setAnglePulse(servo_idx, get_pulse_from_angle_degrees(servo_idx, angle));
}

void setAngleRadians(uint8_t servo_idx, float angle){
  setAnglePulse(servo_idx, get_pulse_from_angle_radians(servo_idx, angle));
}

#endif
#ifndef VEC3_H
#define VEC3_H

#include <math.h> // For sqrtf
#include <stdio.h> // For basic printing/debugging if needed

struct Vec3 {
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;

    // --- Constructors ---
    Vec3() = default; // Default constructor (0, 0, 0)
    Vec3(float x_val, float y_val, float z_val) : x(x_val), y(y_val), z(z_val) {}

    // --- Basic Arithmetic Operators ---

    // Addition
    inline Vec3 operator+(const Vec3& other) const {
        return Vec3(x + other.x, y + other.y, z + other.z);
    }

    // Subtraction
    inline Vec3 operator-(const Vec3& other) const {
        return Vec3(x - other.x, y - other.y, z - other.z);
    }

    // Scalar Multiplication (Vec3 * scalar)
    inline Vec3 operator*(float scalar) const {
        return Vec3(x * scalar, y * scalar, z * scalar);
    }

    // Scalar Division (Vec3 / scalar)
    inline Vec3 operator/(float scalar) const {
        // Basic check for division by zero
        if (fabsf(scalar) < 1e-9f) {
             // Handle error: return zero vector, print warning, or assert
             // Returning zero vector for now
             fprintf(stderr, "Warning: Vec3 division by zero/near-zero.\n");
             return Vec3(0.0f, 0.0f, 0.0f);
        }
        float inv_scalar = 1.0f / scalar;
        return Vec3(x * inv_scalar, y * inv_scalar, z * inv_scalar);
    }

    // Unary Negation
    inline Vec3 operator-() const {
        return Vec3(-x, -y, -z);
    }

    // --- Compound Assignment Operators ---

    inline Vec3& operator+=(const Vec3& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    inline Vec3& operator-=(const Vec3& other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    inline Vec3& operator*=(float scalar) {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

    inline Vec3& operator/=(float scalar) {
        // Basic check for division by zero
        if (fabsf(scalar) < 1e-9f) {
             // Handle error: print warning, leave vector unchanged, or assert
             fprintf(stderr, "Warning: Vec3 compound division by zero/near-zero.\n");
             return *this; // Return unchanged vector
        }
        float inv_scalar = 1.0f / scalar;
        x *= inv_scalar;
        y *= inv_scalar;
        z *= inv_scalar;
        return *this;
    }

    // --- Vector Operations ---

    // Calculate magnitude (length) squared
    inline float normSq() const {
        return x*x + y*y + z*z;
    }

    // Calculate magnitude (length)
    inline float norm() const {
        return sqrtf(normSq());
    }

    // Return a normalized copy of the vector (unit vector)
    inline Vec3 normalized() const {
        float n = norm();
        if (n < 1e-9f) {
            // Handle zero-length vector case
            return Vec3(0.0f, 0.0f, 0.0f); // Or return Vec3(1,0,0) or handle error
        }
        return *this / n;
    }

    // Normalize the vector in-place
    inline void normalize() {
        float n = norm();
        if (n < 1e-9f) {
            // Handle zero-length vector case, maybe set to (0,0,0) or default
            x = 0.0f; y = 0.0f; z = 0.0f;
            return;
        }
        *this /= n;
    }

    // --- Utility ---
    // Basic print function for debugging
    inline void print(const char* label = "Vec3") const {
        printf("%s: (%.4f, %.4f, %.4f)\n", label, x, y, z);
    }
};

// --- Standalone Functions ---

// Scalar Multiplication (scalar * Vec3)
inline Vec3 operator*(float scalar, const Vec3& vec) {
    return vec * scalar; // Reuse the Vec3 * scalar operator
}

// Dot Product
inline float dot(const Vec3& a, const Vec3& b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

// Cross Product
inline Vec3 cross(const Vec3& a, const Vec3& b) {
    return Vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}


#endif // VEC3_H
#ifndef WALK_CYCLE_H
#define WALK_CYCLE_H

#include <math.h>       // For fmod, M_PI, etc.
#include "ik.h"         // For calculateIK
#include "utils.h"      // For Vec3, clampf, setAngleRadians, etc.
#include "robot_spec.h" // For LEG_COUNT, defaultFootPositionWalk, bodyVelocity, etc.
#include "body_transform.h" // For transformWalkFrameToLegFrame

// --- Walk Cycle Parameters ---
// These parameters control the gait characteristics.
// They can be modified dynamically (e.g., by serial or remote commands).
struct WalkParams {
  float stepHeight = 3.0f;
  float stepFrequency = 1.0f;
  float dutyFactor = 0.5f;
};

// --- Per-Leg Walk Cycle State ---
// Stores state information specific to each leg's movement within the cycle.
struct LegCycleData {
  //the latest foot position calculated
  Vec3 currentPosition;

  // Position of the foot in the Walk Frame {X,Y,Z} (cm) at the exact
  // moment it lifted off the ground to begin the swing phase.
  // Used as the starting point for swing trajectory interpolation.
  Vec3 swingStartPosition;
};

extern WalkParams walkParams;
extern LegCycleData legCycleData[LEG_COUNT];
extern bool walkCycleRunning;
extern float globalPhase;

// --- Function Declarations ---
void setupWalkcycle();
void updateWalkCycle(float dt); // Main update function
float bell_curve_lift(float t); // Helper for smooth vertical motion
float quintic_interpolate_pos(float p0, float p1, float v0, float v1, float T, float t); // Helper for smooth XY motion

// --- Global Variable Definitions (Example - could be in a .cpp file) ---
// It's generally better practice to define these in a .cpp file (like walkcycle.cpp or robot_spec.cpp)
// and declare them 'extern' here. But for simplicity in a single-header context:
WalkParams walkParams; // Use default values from struct definition initially
LegCycleData legCycleData[LEG_COUNT];
bool walkCycleRunning = false;
float globalPhase = 0.0f;
// bodyVelocity is defined in robot_spec.cpp

// --- Function Implementations ---

/**
 * @brief Initializes the walk cycle state for each leg.
 * Does NOT move the legs; just sets up internal data structures.
 */
void setupWalkcycle() {
  walkCycleRunning = false; // Ensure walk cycle is stopped initially
  globalPhase = 0.0f;       // Reset phase

  // Initialize leg cycle data based on default stance positions from robot_spec
  for (uint8_t i = 0; i < LEG_COUNT; i++) {

    // Initialize positions to the base positions (neutral stance)
    legCycleData[i].currentPosition = baseFootPositionWalk[i];
    legCycleData[i].swingStartPosition = baseFootPositionWalk[i];
  }
  Serial.println("Walk cycle initialized.");
  // Legs remain in their current position until walkCycleRunning=true and updateWalkCycle is called.
}

/**
 * @brief Generates a smooth vertical lift profile using a bell curve shape.
 * @param t Normalized time within the swing phase (0.0 to 1.0).
 * @return Lift factor (0.0 to 1.0), peaking at t=0.5.
 */
float bell_curve_lift(float t) {
    t = clampf(t, 0.0f, 1.0f);
    // 6th order polynomial approximation of a bell curve (t^3 * (1-t)^3)
    // Scaled by 64 to peak at 1.0 when t=0.5
    float t_minus_1 = 1.0f - t;
    return 64.0f * (t * t * t) * (t_minus_1 * t_minus_1 * t_minus_1);
}

/**
 * @brief Smoothly interpolates position using a quintic Hermite spline.
 * Calculates position at time 't' given start/end positions (p0, p1),
 * start/end velocities (v0, v1), and total duration (T).
 * Ensures position and velocity continuity at endpoints.
 *
 * @param p0 Position at t=0
 * @param p1 Position at t=T
 * @param v0 Velocity at t=0
 * @param v1 Velocity at t=T
 * @param T Total duration of the interpolation
 * @param t Current time (should be 0 <= t <= T)
 * @return Interpolated position at time t
 */
float quintic_interpolate_pos(float p0, float p1, float v0, float v1, float T, float t) {
    if (T <= 1e-9f) return p0; // Avoid division by zero if duration is negligible
    t = clampf(t, 0.0f, T);    // Clamp time within the valid range

    float tn = t / T; // Normalized time (0 to 1)
    float tn2 = tn*tn;
    float tn3 = tn2*tn;
    float tn4 = tn3*tn;
    float tn5 = tn4*tn;

    // Quintic Hermite basis functions (h00, h10, h01, h11 for position)
    // Note: These are derived for POSITION interpolation using start/end pos/vel.
    // (Coefficients for position: a0=p0, a1=v0, a2=0, a3=..., etc.)
    // Derivation leads to these basis functions:
    float h00 =  1.0f - 10.0f*tn3 + 15.0f*tn4 -  6.0f*tn5;
    float h10 =       tn -  6.0f*tn3 +  8.0f*tn4 -  3.0f*tn5; // Scaled by T in use
    float h01 =        + 10.0f*tn3 - 15.0f*tn4 +  6.0f*tn5;
    float h11 =        -  4.0f*tn3 +  7.0f*tn4 -  3.0f*tn5; // Scaled by T in use

    // Calculate interpolated position
    return h00*p0 + h10*T*v0 + h01*p1 + h11*T*v1;
}


/**
 * @brief Main update function for the hexapod walk cycle.
 * Calculates target foot positions in the Walk Frame based on phase and velocity,
 * transforms them into the Leg IK Frame considering body pose,
 * performs IK, and sends commands to servos.
 *
 * @param dt Time elapsed since the last update (in seconds).
 */
void updateWalkCycle(float dt) {
    if (!walkCycleRunning) {
        // If walking is stopped, do nothing. Legs hold their last commanded position.
        return;
    }

    // 1. Update Global Phase
    globalPhase = fmodf(globalPhase + walkParams.stepFrequency * dt, 1.0f);
    if (globalPhase < 0.0f) globalPhase += 1.0f; // Ensure phase is [0, 1)

    // 2. Calculate Cycle Timing Parameters
    // Avoid division by zero if frequency is extremely low
    float T_cycle = (walkParams.stepFrequency > 1e-6f) ? 1.0f / walkParams.stepFrequency : 1e6f;
    // Clamp duty factor to prevent issues, ensure stance/swing times are positive
    float duty_factor = clampf(walkParams.dutyFactor, 0.01f, 0.99f);
    float T_stance = duty_factor * T_cycle;
    float T_swing = T_cycle - T_stance;

    // 3. Loop Through Each Leg
    for (uint8_t i = 0; i < LEG_COUNT; i++) {
        LegCycleData& leg = legCycleData[i]; // Get reference to this leg's state
        //Vec3 P_foot_walk;                    // Calculated target position in Walk Frame for this update

        // Determine leg-specific phase (can add offsets here later for different gaits)
        // Simple example: Tripod gait - Legs 0, 2, 4 step together, Legs 1, 3, 5 step together
        bool isTripodGroup1 = (i == 0 || i == 2 || i == 4); // Example Grouping (BR, FR, CL)
        float phaseOffset = isTripodGroup1 ? 0.0f : 0.5f; // Group 2 is half a cycle offset
        float legPhase = fmodf(globalPhase + phaseOffset, 1.0f);
        if (legPhase < 0.0f) legPhase += 1.0f;

        // 4. Calculate Target Foot Position in Walk Frame

        if (legPhase < duty_factor) {
            // --- STANCE PHASE ---
            // Foot is on the ground and should move backward relative to the body/Walk frame
            // to remain stationary relative to the Ground.

            // Calculate the current foot position by moving backward from the touchdown point
            // based on how long the foot has been in stance.
            leg.currentPosition = leg.currentPosition - (bodyVelocity * dt);
                  
            // Calculate the counter-rotation angle for this timestep
            float delta_angle = -bodyAngularVelocityYaw * dt;
            float cos_da = cosf(delta_angle);
            float sin_da = sinf(delta_angle);
            float original_x = leg.currentPosition.x;
            float original_y = leg.currentPosition.y;
            leg.currentPosition.x = original_x * cos_da - original_y * sin_da;
            leg.currentPosition.y = original_x * sin_da + original_y * cos_da;
            // Z remains unchanged by this 2D rotation



            // **Critical:** Record the current position as the starting point for the *next* swing phase.
            // This captures where the foot actually was just before lifting off.
            leg.swingStartPosition = leg.currentPosition;

        } else {
            // --- SWING PHASE ---
            // Foot is in the air, moving from swingStartPosition to the next target touchdown position.

            // The normalized progress through the swing phase (0.0 to 1.0)
            float swingPhase = (legPhase - duty_factor) / (1.0f - duty_factor);
            
            // The time elapsed *within* the current swing phase
            float time_in_swing = swingPhase * T_swing;

            // The target touchdown position for the *end* of this swing phase.
            // This is where the *next* stance phase will begin. (Same calculation as stanceTouchdownPos above)
            Vec3 linearTargetTouchdownPos = baseFootPositionWalk[i] + (bodyVelocity * (T_stance * 0.5f));

            // Calculate the angle the body will rotate during half a stance phase
            float rotationAngle = bodyAngularVelocityYaw * T_stance * 0.5f;
            float cos_ra = cosf(rotationAngle);
            float sin_ra = sinf(rotationAngle);

            // Store original linear target X before calculating rotated target X
            float original_linear_x = linearTargetTouchdownPos.x;
            // Store original linear target Y (needed for correct Y calculation)
            float original_linear_y = linearTargetTouchdownPos.y;

            // Calculate the final rotated target touchdown position
            Vec3 targetTouchdownPos; // Declare the final target variable
            targetTouchdownPos.x = original_linear_x * cos_ra - original_linear_y * sin_ra;
            targetTouchdownPos.y = original_linear_x * sin_ra + original_linear_y * cos_ra;

            // Set the Z coordinate from the commanded base position (not rotated)
            targetTouchdownPos.z = baseFootPositionWalk[i].z;

            // --- Interpolate Position ---
            // Z Position (Vertical Lift): Use the bell curve for smooth up-and-down motion.
            float lift_curve = bell_curve_lift(swingPhase);
            
            leg.currentPosition.z = mapf(swingPhase, 0.0f, 1.0f, leg.swingStartPosition.z, baseFootPositionWalk[i].z) 
                                + walkParams.stepHeight * lift_curve;

            // XY Position: Use quintic interpolation for smooth horizontal motion.
            // We interpolate from the recorded lift-off point (leg.swingStartPosition)
            // to the calculated target landing point (targetTouchdownPos).
            // Assume zero velocity *relative to the Ground, not Walk Frame* at the start and end of the swing to avoid slippage
            leg.currentPosition.x = quintic_interpolate_pos(
                leg.swingStartPosition.x, targetTouchdownPos.x,
                -bodyVelocity.x, -bodyVelocity.x, // Zero start/end velocity relative to the ground X
                T_swing, time_in_swing);

            leg.currentPosition.y = quintic_interpolate_pos(
                leg.swingStartPosition.y, targetTouchdownPos.y,
                -bodyVelocity.y, -bodyVelocity.y, // Zero start/end velocity relative to the ground Y
                T_swing, time_in_swing);
        }

        // 5. Transform Walk Frame Target to Leg IK Frame Target
        Vec3 P_foot_leg_ik_input; // This will hold the coordinates for calculateIK
        transformWalkFrameToLegFrame(leg.currentPosition, i, P_foot_leg_ik_input);

        // 6. Perform Inverse Kinematics
        float coxa_rad, femur_rad, tibia_rad;
        bool ik_success = calculateIK(i, // Leg index
                                      P_foot_leg_ik_input.x,
                                      P_foot_leg_ik_input.y,
                                      P_foot_leg_ik_input.z,
                                      coxa_rad, femur_rad, tibia_rad); // Outputs

        // 7. Send Commands to Servos if IK Succeeded
        if (ik_success) {
            // Retrieve the correct servo channel numbers for this leg/joint
            uint8_t coxa_servo_channel = LEG_SERVOS[i][0];
            uint8_t femur_servo_channel = LEG_SERVOS[i][1];
            uint8_t tibia_servo_channel = LEG_SERVOS[i][2];

            // Send the calculated angles (in radians) to the low-level servo control function
            setAngleRadians(coxa_servo_channel, coxa_rad);
            setAngleRadians(femur_servo_channel, femur_rad);
            setAngleRadians(tibia_servo_channel, tibia_rad);
        }

    } // End loop through legs
}

#endif // WALK_CYCLE_H
#ifndef WALK_CYCLE_REMOTE_H
#define WALK_CYCLE_REMOTE_H

#include <WiFi.h>
#include <WiFiUdp.h>
#include "robot_spec.h"   // Include AFTER defining LEG_COUNT potentially
#include "packets.h"      // Include the new packet definitions
#include "walkcycle.h"    // Base walk cycle logic
#include "utils.h"        // Utilities like clampf

// --- Network Configuration ---
#ifndef OSSIAN_HEMMA
const char* ssid = "guestnet";         // Replace with your WiFi SSID
const char* password = "VolvoAmazon"; // Replace with your WiFi Password
unsigned int localUdpPort = 5005;           // Port to listen on
#endif
#ifdef OSSIAN_HEMMA
const char* ssid = "Lossby";         // Replace with your WiFi SSID
const char* password = "SL35.WiFi"; // Replace with your WiFi Password
unsigned int localUdpPort = 5005;           // Port to listen on
// --- Angle Broadcast Configuration ---
const char* angleBroadcastIp = "255.255.255.255"; // Broadcast address (adjust if needed, e.g., "192.168.1.255")
unsigned int angleBroadcastPort = 5006;           // Different port for sending angles
// Array to hold the angles before sending. Size = Legs * JointsPerLeg (assuming 3)
// Make sure LEG_COUNT is defined correctly in robot_spec.h!
float jointAnglesToSend[LEG_COUNT * 3];
#endif



// ### Update buffer size for the new packet ###
uint8_t incomingPacketBuffer[sizeof(FullControlPacket)];
uint64_t lastPacketTimestampMs = 0;
uint32_t lastSequenceNumber = 0;
const uint32_t SEQUENCE_IGNORE_WINDOW = 25;
bool logPackets = false;

// Forward declarations
void setupWalkcycleRemote();
bool walkcycleRemoteUpdate();
bool processFullControlPacket();
bool processSerialCommands_remote();
void printSerialHelp();

/**
 * @brief Sets up WiFi connection, UDP listener, and initializes walk cycle state.
 */
void setupWalkcycleRemote() {
  Serial.println("\nSetting up Walk Cycle Remote Control (UDP) - Full Control Mode...");
  setupWalkcycle(); // Initializes walk cycle data using initial defaultFootPositionWalk
  walkCycleRunning = false;
  logPackets = false;
  lastSequenceNumber = 0;
  lastPacketTimestampMs = 0;



  Serial.printf("Starting UDP listener on port %d\n", localUdpPort);
  if (udp.begin(localUdpPort)) {
      // ### Updated expected size message ###
      Serial.printf("UDP Listener started. Expected packet size: %d bytes (FullControlPacket).\n", sizeof(FullControlPacket));
  } else {
      Serial.println("Failed to start UDP Listener! Halting.");
      while(1) { delay(1000); }
  }

  Serial.println("==== Walk Cycle Remote Ready ====");
  printSerialHelp();
  Serial.println("================================");
}

/**
 * @brief Prints available serial commands for this mode.
 */
void printSerialHelp() {
    // ... (Help text remains the same) ...
    Serial.println("\n==== Serial Commands (Remote Mode) ====");
    Serial.println(" L - Toggle UDP Packet Logging (currently " + String(logPackets ? "ON" : "OFF") + ")");
    Serial.println(" X - Exit Remote Control Mode");
    Serial.println(" H / ? - Display this Help");
    Serial.println("=======================================");
}

/**
 * @brief Processes one incoming UDP packet, validates it, and updates robot state.
 * @return True if a packet was available, False otherwise.
 */
bool processFullControlPacket() {
  int packetSize = udp.parsePacket();
  if (!packetSize) {
    return false; // No packet
  }

  IPAddress remoteIp = udp.remoteIP();
  unsigned int remotePort = udp.remotePort();

  if (logPackets) {
    Serial.printf("\nReceived packet: %d bytes from %s:%d\n", packetSize, remoteIp.toString().c_str(), remotePort);
  }

  // --- Validation 1: Packet Size --- ### Use new size ###
  if (packetSize != sizeof(FullControlPacket)) {
    Serial.printf("  [Error] Packet size mismatch! Expected %d, Got %d. Discarding.\n", sizeof(FullControlPacket), packetSize);
    udp.flush();
    return true;
  }

  // Read packet data
  int len = udp.read(incomingPacketBuffer, sizeof(FullControlPacket));
  if (len != sizeof(FullControlPacket)) {
      Serial.printf("  [Error] Failed to read correct # bytes! Read %d. Discarding.\n", len);
      udp.flush();
      return true;
  }

  // Cast buffer to the packet struct pointer
  FullControlPacket* receivedPacket = (FullControlPacket*)incomingPacketBuffer;

  // --- Validation 2: Identifier --- ### Use new identifier ###
  if (receivedPacket->identifier != FULL_CONTROL_PACKET_IDENTIFIER) {
      Serial.printf("  [Error] Invalid packet identifier! Expected 0x%X, Got 0x%X. Discarding.\n",
                    FULL_CONTROL_PACKET_IDENTIFIER, receivedPacket->identifier);
      return true;
  }

  // --- Validation 3: Sequence Number --- (Same logic as before)
  if (receivedPacket->sequenceNumber <= lastSequenceNumber && lastSequenceNumber != 0 && (lastSequenceNumber - receivedPacket->sequenceNumber < SEQUENCE_IGNORE_WINDOW)) {
       if (logPackets) { // Log if needed
          Serial.printf("  [Info] Stale/duplicate sequence number (%u <= %u). Ignoring.\n",
                         receivedPacket->sequenceNumber, lastSequenceNumber);
       }
       return true; // Handled (by ignoring)
  }
  // --- Timestamp checks (same as before) ---
   if (receivedPacket->timestampMs <= lastPacketTimestampMs && logPackets && lastSequenceNumber != 0) {
         Serial.printf("  [Warning] Newer seq (%u > %u) but older timestamp (%llu ms <= %llu ms). Clock skew?\n",
                       receivedPacket->sequenceNumber, lastSequenceNumber,
                       receivedPacket->timestampMs, lastPacketTimestampMs);
   }

  // Update sequence and timestamp tracking
  uint32_t oldSequenceNumber = lastSequenceNumber;
  lastSequenceNumber = receivedPacket->sequenceNumber;
  lastPacketTimestampMs = receivedPacket->timestampMs;


  // --- Optional Detailed Logging (Updated for new fields) ---
  if (logPackets) {
    Serial.println("  --- Processing Valid Packet ---");
    Serial.printf("    Identifier: 0x%X\n", receivedPacket->identifier);
    Serial.printf("    Timestamp: %llu ms\n", receivedPacket->timestampMs);
    Serial.printf("    Sequence #: %u (Prev: %u)\n", receivedPacket->sequenceNumber, oldSequenceNumber);
    Serial.printf("    Raw Flags: 0x%02X\n", receivedPacket->controlFlags);
    Serial.printf("    Raw LinVel(X,Y,Z): (%.2f, %.2f, %.2f)\n", receivedPacket->velocityX, receivedPacket->velocityY, receivedPacket->velocityZ);
    Serial.printf("    Raw AngVel(Yaw): %.3f\n", receivedPacket->angularVelocityYaw);
    Serial.printf("    Raw Gait (H, F, D): (%.2f, %.2f, %.2f)\n", receivedPacket->stepHeight, receivedPacket->stepFrequency, receivedPacket->dutyFactor);
    Serial.printf("    Raw PosOff(X,Y,Z): (%.2f, %.2f, %.2f)\n", receivedPacket->bodyPositionOffsetX, receivedPacket->bodyPositionOffsetY, receivedPacket->bodyPositionOffsetZ);
    Serial.printf("    Raw Orient(W,X,Y,Z): (%.3f, %.3f, %.3f, %.3f)\n", receivedPacket->bodyOrientationW, receivedPacket->bodyOrientationX, receivedPacket->bodyOrientationY, receivedPacket->bodyOrientationZ);
    // ### Log received base foot positions ###
    Serial.println("    Raw Base Foot Pos (XYZ):");
    for (int i = 0; i < LEG_COUNT; ++i) {
        Serial.printf("      L%d: (%.1f, %.1f, %.1f)\n", i,
                      receivedPacket->baseFootPosXYZ[i * 3 + 0],
                      receivedPacket->baseFootPosXYZ[i * 3 + 1],
                      receivedPacket->baseFootPosXYZ[i * 3 + 2]);
    }
    Serial.println("  ---------------------------------");
  }

  // --- Apply Packet Data to Robot State ---

  // 1. Update Walk Cycle Running State (Same as before)
  bool newRunningState = (receivedPacket->controlFlags & FLAG_WALK_RUNNING) != 0;
  if (newRunningState && !walkCycleRunning) { globalPhase = 0.0f; /* Reset phase */ }
  walkCycleRunning = newRunningState;

  // 2. Update Velocities (Same as before)
  bodyVelocity.x = receivedPacket->velocityX;
  bodyVelocity.y = receivedPacket->velocityY;
  bodyVelocity.z = receivedPacket->velocityZ;
  bodyAngularVelocityYaw = receivedPacket->angularVelocityYaw;

  // 3. Update Walk Parameters (Same as before)
  walkParams.stepHeight = receivedPacket->stepHeight;
  walkParams.stepFrequency = receivedPacket->stepFrequency;
  walkParams.dutyFactor = clampf(receivedPacket->dutyFactor, 0.01f, 0.99f);

  // 4. Update Body Pose (Same as before)
  bodyPositionOffset.x = receivedPacket->bodyPositionOffsetX;
  bodyPositionOffset.y = receivedPacket->bodyPositionOffsetY;
  bodyPositionOffset.z = receivedPacket->bodyPositionOffsetZ;
  bodyOrientation.w = receivedPacket->bodyOrientationW;
  bodyOrientation.x = receivedPacket->bodyOrientationX;
  bodyOrientation.y = receivedPacket->bodyOrientationY;
  bodyOrientation.z = receivedPacket->bodyOrientationZ;
  bodyOrientation.normalize();

  // 5. ### Update Base Foot Positions ###
  for (int i = 0; i < LEG_COUNT; ++i) {
      // Direct copy from packet into the global array
      baseFootPositionWalk[i].x = receivedPacket->baseFootPosXYZ[i * 3 + 0];
      baseFootPositionWalk[i].y = receivedPacket->baseFootPosXYZ[i * 3 + 1];
      baseFootPositionWalk[i].z = receivedPacket->baseFootPosXYZ[i * 3 + 2];
  }

   if (logPackets) { // Log applied state (optional: add base pos here too)
     Serial.println("  Applied state:");
     Serial.printf("    walkCycleRunning: %s\n", walkCycleRunning ? "true":"false");
     // ... (log other applied states) ...
     // Example logging applied base positions:
     Serial.println("    Applied Base Foot Pos (XYZ):");
     for (int i = 0; i < LEG_COUNT; ++i) {
         Serial.printf("      L%d: (%.1f, %.1f, %.1f)\n", i,
                       baseFootPositionWalk[i].x,
                       baseFootPositionWalk[i].y,
                       baseFootPositionWalk[i].z);
     }
   }

  return true; // Packet processed
}


/**
 * @brief Processes incoming serial commands (like toggling logs or exiting).
 * @return True to continue running, False to exit.
 */
bool processSerialCommands_remote() {
    // ... (This function remains unchanged) ...
    if (Serial.available() > 0) {
        char command = Serial.read();
        while (Serial.available() > 0 && (Serial.peek() == '\n' || Serial.peek() == '\r')) { Serial.read(); }
        switch (toupper(command)) {
            case 'L': logPackets = !logPackets; Serial.printf("\nPacket Logging: %s\n", logPackets ? "ON" : "OFF"); printSerialHelp(); break;
            case 'X': Serial.println("\nExiting Remote Mode..."); walkCycleRunning = false; return false;
            case 'H': case '?': printSerialHelp(); break;
            default: if (isprint(command)) { Serial.printf("\nUnknown command: '%c'. H for help.\n", command); } break;
        }
    }
    return true;
}

/**
 * @brief Main update loop for the remote walk cycle mode.
 * @return True to continue running, False to exit.
 */
bool walkcycleRemoteUpdate() {
  // ... (Structure remains the same) ...
  // 1. Check Serial Commands
  if (!processSerialCommands_remote()) {
    return false;
  }

  // 2. Process Incoming UDP Packet(s)
  // Process multiple packets if available quickly? Or just one per loop?
  // Processing just one is usually fine and simpler.
  processFullControlPacket();

  // 3. Calculate Time Delta (dt)
  // ... (dt calculation and clamping logic remains the same) ...
  static unsigned long lastUpdateTimeMicros = 0;
  unsigned long nowMicros = micros();
  if (lastUpdateTimeMicros == 0 || nowMicros < lastUpdateTimeMicros) { lastUpdateTimeMicros = nowMicros; }
  float dt = (nowMicros - lastUpdateTimeMicros) / 1000000.0f;
  lastUpdateTimeMicros = nowMicros;
  if (dt < 0.0f || dt > 0.1f) {
      if (logPackets && dt != 0.0f) { Serial.printf("[Warning] Unusual dt: %.4f s. Clamping to 0.01s\n", dt); }
      dt = 0.01f;
  }


  // 4. Update Walk Cycle Logic if Running
  if (walkCycleRunning) {
      updateWalkCycle(dt); // This now implicitly uses the updated defaultFootPositionWalk values
  }

  return true;
}

#endif // WALK_CYCLE_REMOTE_H
#ifndef WALK_CYCLE_SERIAL_H
#define WALK_CYCLE_SERIAL_H

#include "walkcycle.h"

void setupWalkcycleSerial() {
  setupWalkcycle();
  
  Serial.println("\n==== Leg Walk Cycle Control ====");
  Serial.println("Commands:");
  Serial.println("x[value] - Set x velocity (cm/s)");
  Serial.println("y[value] - Set y velocity (cm/s)");
  Serial.println("z[value] - Set z velocity (cm/s)");
  Serial.println("G - Go/Start walk cycle");
  Serial.println("B - Break/Stop walk cycle");
  Serial.println("D - Display current status");
  Serial.println("X - Exit to main menu");
  Serial.println("S - Set step height");
  Serial.println("F - Set step frequency");
  Serial.println("========================");

}

bool processWalkCommands() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    input.trim();
    
    if (input.length() > 0) {
      char command = input.charAt(0);
      input = input.substring(1); // Remove command character
      
      switch (command) {
        case 'X': // Exit program
          walkCycleRunning = false;
          Serial.println("Exiting walk cycle");
          return false;
          
        case 'B': // Break/Stop
          walkCycleRunning = false;
          Serial.println("Walk cycle stopped");
          break;
          
        case 'G': // Go/Start
          walkCycleRunning = true;
          globalPhase = 0.0f;
          Serial.println("Walk cycle started");
          break;
          
        case 'x': // Set X velocity
          bodyVelocity.x = input.toFloat();
          Serial.print("X velocity set to ");
          Serial.println(bodyVelocity.x);
          break;
          
        case 'y': // Set Y velocity
          bodyVelocity.y = input.toFloat();
          Serial.print("Y velocity set to ");
          Serial.println(bodyVelocity.y);
          break;
          
        case 'z': // Set Z velocity
          bodyVelocity.z = input.toFloat();
          Serial.print("Z velocity set to ");
          Serial.println(bodyVelocity.z);
          break;
          
        case 'S': // Set step height
          walkParams.stepHeight = input.toFloat();
          Serial.print("Step height set to ");
          Serial.println(walkParams.stepHeight);
          break;
          
        case 'F': // Set step frequency
          walkParams.stepFrequency = input.toFloat();
          Serial.print("Step frequency set to ");
          Serial.println(walkParams.stepFrequency);
          break;
          
        case 'D': // Display current status
          Serial.print("Body velocity: X=");
          Serial.print(bodyVelocity.x);
          Serial.print(" Y=");
          Serial.print(bodyVelocity.y);
          Serial.print(" Z=");
          Serial.println(bodyVelocity.z);
          
          Serial.print("Step height: ");
          Serial.print(walkParams.stepHeight);
          Serial.print("cm, Frequency: ");
          Serial.print(walkParams.stepFrequency);
          Serial.println("Hz");
          
          for (uint8_t i = 0; i < LEG_COUNT; i++) {
            Serial.print("Leg ");
            Serial.print(i);
            Serial.print(": ");
            Serial.print("X=");
            Serial.print(legTargets[i].x);
            Serial.print(" Y=");
            Serial.print(legTargets[i].y);
            Serial.print(" Z=");
            Serial.println(legTargets[i].z);
          }
          break;
          
        default:
          Serial.println("Unknown command");
          break;
      }
    }
  }
  return true;
}

bool walkcycleSerialUpdate() {
  static unsigned long lastUpdate = 0;
  unsigned long now = millis();
  float dt = (now - lastUpdate) / 1000.0f;
  lastUpdate = now;
  
  if (walkCycleRunning) updateWalkCycle(dt);
  
  return processWalkCommands();
}

#endif
